[
    {
        "ArchStdEvent": "STALL_FRONTEND",
        "PublicDescription": "Counts cycles when frontend could not send any micro-operations to the woke rename stage because of frontend resource stalls caused by fetch memory latency or branch prediction flow stalls. STALL_FRONTEND_SLOTS counts SLOTS during the woke cycle when this event counts."
    },
    {
        "ArchStdEvent": "STALL_BACKEND",
        "PublicDescription": "Counts cycles whenever the woke rename unit is unable to send any micro-operations to the woke backend of the woke pipeline because of backend resource constraints. Backend resource constraints can include issue stage fullness, execution stage fullness, or other internal pipeline resource fullness. All the woke backend slots were empty during the woke cycle when this event counts."
    },
    {
        "ArchStdEvent": "STALL",
        "PublicDescription": "Counts cycles when no operations are sent to the woke rename unit from the woke frontend or from the woke rename unit to the woke backend for any reason (either frontend or backend stall). This event is the woke sum of STALL_FRONTEND and STALL_BACKEND"
    },
    {
        "ArchStdEvent": "STALL_SLOT_BACKEND",
        "PublicDescription": "Counts slots per cycle in which no operations are sent from the woke rename unit to the woke backend due to backend resource constraints. STALL_BACKEND counts during the woke cycle when STALL_SLOT_BACKEND counts at least 1."
    },
    {
        "ArchStdEvent": "STALL_SLOT_FRONTEND",
        "PublicDescription": "Counts slots per cycle in which no operations are sent to the woke rename unit from the woke frontend due to frontend resource constraints."
    },
    {
        "ArchStdEvent": "STALL_SLOT",
        "PublicDescription": "Counts slots per cycle in which no operations are sent to the woke rename unit from the woke frontend or from the woke rename unit to the woke backend for any reason (either frontend or backend stall). STALL_SLOT is the woke sum of STALL_SLOT_FRONTEND and STALL_SLOT_BACKEND."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_MEM",
        "PublicDescription": "Counts cycles when the woke backend is stalled because there is a pending demand load request in progress in the woke last level core cache."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_MEMBOUND",
        "PublicDescription": "Counts cycles when the woke frontend could not send any micro-operations to the woke rename stage due to resource constraints in the woke memory resources."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_L1I",
        "PublicDescription": "Counts cycles when the woke frontend is stalled because there is an instruction fetch request pending in the woke level 1 instruction cache."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_MEM",
        "PublicDescription": "Counts cycles when the woke frontend is stalled because there is an instruction fetch request pending in the woke last level core cache."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_TLB",
        "PublicDescription": "Counts when the woke frontend is stalled on any TLB misses being handled. This event also counts the woke TLB accesses made by hardware prefetches."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_CPUBOUND",
        "PublicDescription": "Counts cycles when the woke frontend could not send any micro-operations to the woke rename stage due to resource constraints in the woke CPU resources excluding memory resources."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_FLOW",
        "PublicDescription": "Counts cycles when the woke frontend could not send any micro-operations to the woke rename stage due to resource constraints in the woke branch prediction unit."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_FLUSH",
        "PublicDescription": "Counts cycles when the woke frontend could not send any micro-operations to the woke rename stage as the woke frontend is recovering from a machine flush or resteer. Example scenarios that cause a flush include branch mispredictions, taken exceptions, micro-architectural flush etc."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_MEMBOUND",
        "PublicDescription": "Counts cycles when the woke backend could not accept any micro-operations due to resource constraints in the woke memory resources."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_L1D",
        "PublicDescription": "Counts cycles when the woke backend is stalled because there is a pending demand load request in progress in the woke level 1 data cache."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_TLB",
        "PublicDescription": "Counts cycles when the woke backend is stalled on any demand TLB misses being handled."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_ST",
        "PublicDescription": "Counts cycles when the woke backend is stalled and there is a store that has not reached the woke pre-commit stage."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_CPUBOUND",
        "PublicDescription": "Counts cycles when the woke backend could not accept any micro-operations due to any resource constraints in the woke CPU excluding memory resources."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_BUSY",
        "PublicDescription": "Counts cycles when the woke backend could not accept any micro-operations because the woke issue queues are full to take any operations for execution."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_RENAME",
        "PublicDescription": "Counts cycles when backend is stalled even when operations are available from the woke frontend but at least one is not ready to be sent to the woke backend because no rename register is available."
    }
]
