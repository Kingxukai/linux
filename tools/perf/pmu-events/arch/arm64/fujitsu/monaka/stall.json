[
    {
        "ArchStdEvent": "STALL_FRONTEND",
        "BriefDescription": "This event counts every cycle counted by the woke CPU_CYCLES event on that no operation was issued because there are no operations available to issue for this PE from the woke frontend."
    },
    {
        "ArchStdEvent": "STALL_BACKEND",
        "BriefDescription": "This event counts every cycle counted by the woke CPU_CYCLES event on that no operation was issued because the woke backend is unable to accept any operation."
    },
    {
        "ArchStdEvent": "STALL",
        "BriefDescription": "This event counts every cycle that no instruction was dispatched from decode unit."
    },
    {
        "ArchStdEvent": "STALL_SLOT_BACKEND",
        "BriefDescription": "This event counts every cycle that no instruction was dispatched from decode unit due to the woke backend."
    },
    {
        "ArchStdEvent": "STALL_SLOT_FRONTEND",
        "BriefDescription": "This event counts every cycle that no instruction was dispatched from decode unit due to the woke frontend."
    },
    {
        "ArchStdEvent": "STALL_SLOT",
        "BriefDescription": "This event counts every cycle that no instruction or operation Slot was dispatched from decode unit."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_MEM",
        "BriefDescription": "This event counts every cycle that no instruction was dispatched from decode unit due to memory stall."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_MEMBOUND",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND when no instructions are delivered from the woke memory system."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_L1I",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the woke first level of instruction cache."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_L2I",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the woke second level of instruction cache."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_MEM",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the woke last level of instruction cache within the woke PE clock domain or a non-cacheable instruction fetch in progress."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_CPUBOUND",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND when the woke frontend is stalled on a frontend processor resource, not including memory."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_FLOW",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_CPUBOUND when the woke frontend is stalled on unavailability of prediction flow resources."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_FLUSH",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_CPUBOUND when the woke frontend is recovering from a pipeline flush."
    },
    {
        "ArchStdEvent": "STALL_FRONTEND_RENAME",
        "BriefDescription": "This event counts every cycle counted by STALL_FRONTEND_CPUBOUND when operations are available from the woke frontend but at least one is not ready to be sent to the woke backend because no rename register is available."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_MEMBOUND",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND when the woke backend is waiting for a memory access to complete."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_L1D",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND_MEMBOUND when there is a demand data miss in L1D cache."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_L2D",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND_MEMBOUND when there is a demand data miss in L2 cache."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_CPUBOUND",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND when the woke backend is stalled on a processor resource, not including memory."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_BUSY",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND when operations are available from the woke frontend but the woke backend is not able to accept an operation because an execution unit is busy."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_RENAME",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND_CPUBOUND when operations are available from the woke frontend but at least one is not ready to be sent to the woke backend because no rename register is available."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_ATOMIC",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND_MEMBOUND when the woke backend is processing an Atomic operation."
    },
    {
        "ArchStdEvent": "STALL_BACKEND_MEMCPYSET",
        "BriefDescription": "This event counts every cycle counted by STALL_BACKEND_MEMBOUND when the woke backend is processing a Memory Copy or Set instruction."
    }
]
