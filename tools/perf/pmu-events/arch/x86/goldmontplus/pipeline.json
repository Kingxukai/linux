[
    {
        "BriefDescription": "Retired branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
        "PEBS": "2",
        "PublicDescription": "Counts branch instructions retired for all branch types.  This is an architectural performance event.",
        "SampleAfterValue": "200003"
    },
    {
        "BriefDescription": "Retired taken branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.ALL_TAKEN_BRANCHES",
        "PEBS": "2",
        "PublicDescription": "Counts the woke number of taken branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Retired near call instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.CALL",
        "PEBS": "2",
        "PublicDescription": "Counts near CALL branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0xf9"
    },
    {
        "BriefDescription": "Retired far branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.FAR_BRANCH",
        "PEBS": "2",
        "PublicDescription": "Counts far branch instructions retired.  This includes far jump, far call and return, and Interrupt call and return.",
        "SampleAfterValue": "200003",
        "UMask": "0xbf"
    },
    {
        "BriefDescription": "Retired near indirect call instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.IND_CALL",
        "PEBS": "2",
        "PublicDescription": "Counts near indirect CALL branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0xfb"
    },
    {
        "BriefDescription": "Retired conditional branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.JCC",
        "PEBS": "2",
        "PublicDescription": "Counts retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired, including both when the woke branch was taken and when it was not taken.",
        "SampleAfterValue": "200003",
        "UMask": "0x7e"
    },
    {
        "BriefDescription": "Retired instructions of near indirect Jmp or call (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.NON_RETURN_IND",
        "PEBS": "2",
        "PublicDescription": "Counts near indirect call or near indirect jmp branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0xeb"
    },
    {
        "BriefDescription": "Retired near relative call instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.REL_CALL",
        "PEBS": "2",
        "PublicDescription": "Counts near relative CALL branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0xfd"
    },
    {
        "BriefDescription": "Retired near return instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.RETURN",
        "PEBS": "2",
        "PublicDescription": "Counts near return branch instructions retired.",
        "SampleAfterValue": "200003",
        "UMask": "0xf7"
    },
    {
        "BriefDescription": "Retired conditional branch instructions that were taken (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC4",
        "EventName": "BR_INST_RETIRED.TAKEN_JCC",
        "PEBS": "2",
        "PublicDescription": "Counts Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired that were taken and does not count when the woke Jcc branch instruction were not taken.",
        "SampleAfterValue": "200003",
        "UMask": "0xfe"
    },
    {
        "BriefDescription": "Retired mispredicted branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted branch instructions retired including all branch types.",
        "SampleAfterValue": "200003"
    },
    {
        "BriefDescription": "Retired mispredicted near indirect call instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.IND_CALL",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted near indirect CALL branch instructions retired, where the woke target address taken was not what the woke processor predicted.",
        "SampleAfterValue": "200003",
        "UMask": "0xfb"
    },
    {
        "BriefDescription": "Retired mispredicted conditional branch instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.JCC",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired, including both when the woke branch was supposed to be taken and when it was not supposed to be taken (but the woke processor predicted the woke opposite condition).",
        "SampleAfterValue": "200003",
        "UMask": "0x7e"
    },
    {
        "BriefDescription": "Retired mispredicted instructions of near indirect Jmp or near indirect call (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.NON_RETURN_IND",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted branch instructions retired that were near indirect call or near indirect jmp, where the woke target address taken was not what the woke processor predicted.",
        "SampleAfterValue": "200003",
        "UMask": "0xeb"
    },
    {
        "BriefDescription": "Retired mispredicted near return instructions (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.RETURN",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted near RET branch instructions retired, where the woke return address taken was not what the woke processor predicted.",
        "SampleAfterValue": "200003",
        "UMask": "0xf7"
    },
    {
        "BriefDescription": "Retired mispredicted conditional branch instructions that were taken (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC5",
        "EventName": "BR_MISP_RETIRED.TAKEN_JCC",
        "PEBS": "2",
        "PublicDescription": "Counts mispredicted retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired that were supposed to be taken but the woke processor predicted that it would not be taken.",
        "SampleAfterValue": "200003",
        "UMask": "0xfe"
    },
    {
        "BriefDescription": "Core cycles when core is not halted  (Fixed event)",
        "Counter": "Fixed counter 1",
        "EventName": "CPU_CLK_UNHALTED.CORE",
        "PublicDescription": "Counts the woke number of core cycles while the woke core is not in a halt state.  The core enters the woke halt state when it is running the woke HLT instruction. In mobile systems the woke core frequency may change from time to time. For this reason this event may have a changing ratio with regards to time.  This event uses fixed counter 1.  You cannot collect a PEBs record for this event.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Core cycles when core is not halted",
        "Counter": "0,1,2,3",
        "EventCode": "0x3C",
        "EventName": "CPU_CLK_UNHALTED.CORE_P",
        "PublicDescription": "Core cycles when core is not halted.  This event uses a (_P)rogrammable general purpose performance counter.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Reference cycles when core is not halted",
        "Counter": "0,1,2,3",
        "EventCode": "0x3C",
        "EventName": "CPU_CLK_UNHALTED.REF",
        "PublicDescription": "Reference cycles when core is not halted.  This event uses a (_P)rogrammable general purpose performance counter.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Reference cycles when core is not halted  (Fixed event)",
        "Counter": "Fixed counter 2",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC",
        "PublicDescription": "Counts the woke number of reference cycles that the woke core is not in a halt state. The core enters the woke halt state when it is running the woke HLT instruction.  In mobile systems the woke core frequency may change from time.  This event is not affected by core frequency changes but counts as if the woke core is running at the woke maximum frequency all the woke time.  This event uses fixed counter 2.  You cannot collect a PEBs record for this event.",
        "SampleAfterValue": "2000003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "Cycles a divider is busy",
        "Counter": "0,1,2,3",
        "EventCode": "0xCD",
        "EventName": "CYCLES_DIV_BUSY.ALL",
        "PublicDescription": "Counts core cycles if either divide unit is busy.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Cycles the woke integer divide unit is busy",
        "Counter": "0,1,2,3",
        "EventCode": "0xCD",
        "EventName": "CYCLES_DIV_BUSY.IDIV",
        "PublicDescription": "Counts core cycles the woke integer divide unit is busy.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Instructions retired (Fixed event)",
        "Counter": "Fixed counter 0",
        "EventName": "INST_RETIRED.ANY",
        "PEBS": "2",
        "PublicDescription": "Counts the woke number of instructions that retire execution. For instructions that consist of multiple uops, this event counts the woke retirement of the woke last uop of the woke instruction. The counter continues counting during hardware interrupts, traps, and inside interrupt handlers.  This event uses fixed counter 0.  You cannot collect a PEBs record for this event.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Instructions retired (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC0",
        "EventName": "INST_RETIRED.ANY_P",
        "PEBS": "2",
        "PublicDescription": "Counts the woke number of instructions that retire execution. For instructions that consist of multiple uops, this event counts the woke retirement of the woke last uop of the woke instruction. The event continues counting during hardware interrupts, traps, and inside interrupt handlers.  This is an architectural performance event.  This event uses a (_P)rogrammable general purpose performance counter. *This event is Precise Event capable:  The EventingRIP field in the woke PEBS record is precise to the woke address of the woke instruction which caused the woke event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the woke PEBS facility at a time.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Instructions retired - using Reduced Skid PEBS feature",
        "Counter": "0,1,2,3",
        "EventCode": "0xC0",
        "EventName": "INST_RETIRED.PREC_DIST",
        "PEBS": "2",
        "PublicDescription": "Counts INST_RETIRED.ANY using the woke Reduced Skid PEBS feature that reduces the woke shadow in which events aren't counted allowing for a more unbiased distribution of samples across instructions retired.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Unfilled issue slots per cycle",
        "Counter": "0,1,2,3",
        "EventCode": "0xCA",
        "EventName": "ISSUE_SLOTS_NOT_CONSUMED.ANY",
        "PublicDescription": "Counts the woke number of issue slots per core cycle that were not consumed by the woke backend due to either a full resource  in the woke backend (RESOURCE_FULL) or due to the woke processor recovering from some event (RECOVERY).",
        "SampleAfterValue": "200003"
    },
    {
        "BriefDescription": "Unfilled issue slots per cycle to recover",
        "Counter": "0,1,2,3",
        "EventCode": "0xCA",
        "EventName": "ISSUE_SLOTS_NOT_CONSUMED.RECOVERY",
        "PublicDescription": "Counts the woke number of issue slots per core cycle that were not consumed by the woke backend because allocation is stalled waiting for a mispredicted jump to retire or other branch-like conditions (e.g. the woke event is relevant during certain microcode flows).   Counts all issue slots blocked while within this window including slots where uops were not available in the woke Instruction Queue.",
        "SampleAfterValue": "200003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Unfilled issue slots per cycle because of a full resource in the woke backend",
        "Counter": "0,1,2,3",
        "EventCode": "0xCA",
        "EventName": "ISSUE_SLOTS_NOT_CONSUMED.RESOURCE_FULL",
        "PublicDescription": "Counts the woke number of issue slots per core cycle that were not consumed because of a full resource in the woke backend.  Including but not limited to resources such as the woke Re-order Buffer (ROB), reservation stations (RS), load/store buffers, physical registers, or any other needed machine resource that is currently unavailable.   Note that uops must be available for consumption in order for this event to fire.  If a uop is not available (Instruction Queue is empty), this event will not count.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Loads blocked because address has 4k partial address false dependence (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.4K_ALIAS",
        "PEBS": "2",
        "PublicDescription": "Counts loads that block because their address modulo 4K matches a pending store.",
        "SampleAfterValue": "200003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Loads blocked (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.ALL_BLOCK",
        "PEBS": "2",
        "PublicDescription": "Counts anytime a load that retires is blocked for any reason.",
        "SampleAfterValue": "200003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Loads blocked due to store data not ready (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.DATA_UNKNOWN",
        "PEBS": "2",
        "PublicDescription": "Counts a load blocked from using a store forward, but did not occur because the woke store data was not available at the woke right time.  The forward might occur subsequently when the woke data is available.",
        "SampleAfterValue": "200003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Loads blocked due to store forward restriction (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "PEBS": "2",
        "PublicDescription": "Counts a load blocked from using a store forward because of an address/size mismatch, only one of the woke loads blocked from each store will be counted.",
        "SampleAfterValue": "200003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Loads blocked because address in not in the woke UTLB (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.UTLB_MISS",
        "PEBS": "2",
        "PublicDescription": "Counts loads blocked because they are unable to find their physical address in the woke micro TLB (UTLB).",
        "SampleAfterValue": "200003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "All machine clears",
        "Counter": "0,1,2,3",
        "EventCode": "0xC3",
        "EventName": "MACHINE_CLEARS.ALL",
        "PublicDescription": "Counts machine clears for any reason.",
        "SampleAfterValue": "20003"
    },
    {
        "BriefDescription": "Machine clears due to memory disambiguation",
        "Counter": "0,1,2,3",
        "EventCode": "0xC3",
        "EventName": "MACHINE_CLEARS.DISAMBIGUATION",
        "PublicDescription": "Counts machine clears due to memory disambiguation.  Memory disambiguation happens when a load which has been issued conflicts with a previous unretired store in the woke pipeline whose address was not known at issue time, but is later resolved to be the woke same as the woke load address.",
        "SampleAfterValue": "20003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Machines clear due to a page fault",
        "Counter": "0,1,2,3",
        "EventCode": "0xC3",
        "EventName": "MACHINE_CLEARS.PAGE_FAULT",
        "PublicDescription": "Counts the woke number of times that the woke machines clears due to a page fault. Covers both I-side and D-side(Loads/Stores) page faults. A page fault occurs when either page is not present, or an access violation",
        "SampleAfterValue": "20003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Self-Modifying Code detected",
        "Counter": "0,1,2,3",
        "EventCode": "0xC3",
        "EventName": "MACHINE_CLEARS.SMC",
        "PublicDescription": "Counts the woke number of times that the woke processor detects that a program is writing to a code section and has to perform a machine clear because of that modification.  Self-modifying code (SMC) causes a severe penalty in all Intel(R) architecture processors.",
        "SampleAfterValue": "20003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Uops issued to the woke back end per cycle",
        "Counter": "0,1,2,3",
        "EventCode": "0x0E",
        "EventName": "UOPS_ISSUED.ANY",
        "PublicDescription": "Counts uops issued by the woke front end and allocated into the woke back end of the woke machine.  This event counts uops that retire as well as uops that were speculatively executed but didn't retire. The sort of speculative uops that might be counted includes, but is not limited to those uops issued in the woke shadow of a miss-predicted branch, those uops that are inserted during an assist (such as for a denormal floating point result), and (previously allocated) uops that might be canceled during a machine clear.",
        "SampleAfterValue": "200003"
    },
    {
        "BriefDescription": "Uops requested but not-delivered to the woke back-end per cycle",
        "Counter": "0,1,2,3",
        "EventCode": "0x9C",
        "EventName": "UOPS_NOT_DELIVERED.ANY",
        "PublicDescription": "This event used to measure front-end inefficiencies. I.e. when front-end of the woke machine is not delivering uops to the woke back-end and the woke back-end has is not stalled. This event can be used to identify if the woke machine is truly front-end bound.  When this event occurs, it is an indication that the woke front-end of the woke machine is operating at less than its theoretical peak performance. Background: We can think of the woke processor pipeline as being divided into 2 broader parts: Front-end and Back-end. Front-end is responsible for fetching the woke instruction, decoding into uops in machine understandable format and putting them into a uop queue to be consumed by back end. The back-end then takes these uops, allocates the woke required resources.  When all resources are ready, uops are executed. If the woke back-end is not ready to accept uops from the woke front-end, then we do not want to count these as front-end bottlenecks.  However, whenever we have bottlenecks in the woke back-end, we will have allocation unit stalls and eventually forcing the woke front-end to wait until the woke back-end is ready to receive more uops. This event counts only when back-end is requesting more uops and front-end is not able to provide them. When 3 uops are requested and no uops are delivered, the woke event counts 3. When 3 are requested, and only 1 is delivered, the woke event counts 2. When only 2 are delivered, the woke event counts 1. Alternatively stated, the woke event will not count if 3 uops are delivered, or if the woke back end is stalled and not requesting any uops at all.  Counts indicate missed opportunities for the woke front-end to deliver a uop to the woke back end. Some examples of conditions that cause front-end efficiencies are: ICache misses, ITLB misses, and decoder restrictions that limit the woke front-end bandwidth. Known Issues: Some uops require multiple allocation slots.  These uops will not be charged as a front end 'not delivered' opportunity, and will be regarded as a back end problem. For example, the woke INC instruction has one uop that requires 2 issue slots.  A stream of INC instructions will not count as UOPS_NOT_DELIVERED, even though only one instruction can be issued per clock.  The low uop issue rate for a stream of INC instructions is considered to be a back end issue.",
        "SampleAfterValue": "200003"
    },
    {
        "BriefDescription": "Uops retired (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC2",
        "EventName": "UOPS_RETIRED.ANY",
        "PEBS": "2",
        "PublicDescription": "Counts uops which retired.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Integer divide uops retired (Precise Event Capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC2",
        "EventName": "UOPS_RETIRED.IDIV",
        "PEBS": "2",
        "PublicDescription": "Counts the woke number of integer divide uops retired.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "MS uops retired (Precise event capable)",
        "Counter": "0,1,2,3",
        "EventCode": "0xC2",
        "EventName": "UOPS_RETIRED.MS",
        "PEBS": "2",
        "PublicDescription": "Counts uops retired that are from the woke complex flows issued by the woke micro-sequencer (MS).  Counts both the woke uops from a micro-coded instruction, and the woke uops that might be generated from a micro-coded assist.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    }
]
