[
    {
        "BriefDescription": "DRAM Activate Count",
        "Counter": "0,1,2,3",
        "EventCode": "0x1",
        "EventName": "UNC_M_ACT_COUNT",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of DRAM Activate commands sent on this channel.  Activate commands are issued to open up a page on the woke DRAM devices so that it can be read or written to with a CAS.  One can calculate the woke number of Page Misses by subtracting the woke number of Page Miss precharges from the woke number of Activates.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR_CAS (w/ and w/out auto-pre)",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.ALL",
        "PerPkg": "1",
        "UMask": "0xf",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM Reads (RD_CAS + Underfills)",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.RD",
        "PerPkg": "1",
        "UMask": "0x3",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM RD_CAS (w/ and w/out auto-pre)",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.RD_REG",
        "PerPkg": "1",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Underfill Read Issued",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.RD_UNDERFILL",
        "PerPkg": "1",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR_CAS (both Modes)",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.WR",
        "PerPkg": "1",
        "UMask": "0xc",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS (w/ and w/out auto-pre) in Read Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.WR_RMM",
        "PerPkg": "1",
        "UMask": "0x8",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS (w/ and w/out auto-pre) in Write Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x4",
        "EventName": "UNC_M_CAS_COUNT.WR_WMM",
        "PerPkg": "1",
        "UMask": "0x4",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "uclks",
        "Counter": "0,1,2,3",
        "EventName": "UNC_M_CLOCKTICKS",
        "PerPkg": "1",
        "PublicDescription": "Uncore Fixed Counter - uclks",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM Precharge All Commands",
        "Counter": "0,1,2,3",
        "EventCode": "0x6",
        "EventName": "UNC_M_DRAM_PRE_ALL",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of times that the woke precharge all command was sent.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Number of DRAM Refreshes Issued",
        "Counter": "0,1,2,3",
        "EventCode": "0x5",
        "EventName": "UNC_M_DRAM_REFRESH.HIGH",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of refreshes issued.",
        "UMask": "0x4",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Number of DRAM Refreshes Issued",
        "Counter": "0,1,2,3",
        "EventCode": "0x5",
        "EventName": "UNC_M_DRAM_REFRESH.PANIC",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of refreshes issued.",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "ECC Correctable Errors",
        "Counter": "0,1,2,3",
        "EventCode": "0x9",
        "EventName": "UNC_M_ECC_CORRECTABLE_ERRORS",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of ECC errors detected and corrected by the woke iMC on this channel.  This counter is only useful with ECC DRAM devices.  This count will increment one time for each correction regardless of the woke number of bits corrected.  The iMC can correct up to 4 bit errors in independent channel mode and 8 bit errors in lockstep mode.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Cycles in a Major Mode; Isoch Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x7",
        "EventName": "UNC_M_MAJOR_MODES.ISOCH",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke total number of cycles spent in a major mode (selected by a filter) on the woke given channel.   Major modea are channel-wide, and not a per-rank (or dimm or bank) mode.",
        "UMask": "0x8",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Cycles in a Major Mode; Partial Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x7",
        "EventName": "UNC_M_MAJOR_MODES.PARTIAL",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke total number of cycles spent in a major mode (selected by a filter) on the woke given channel.   Major modea are channel-wide, and not a per-rank (or dimm or bank) mode.",
        "UMask": "0x4",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Cycles in a Major Mode; Read Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x7",
        "EventName": "UNC_M_MAJOR_MODES.READ",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke total number of cycles spent in a major mode (selected by a filter) on the woke given channel.   Major modea are channel-wide, and not a per-rank (or dimm or bank) mode.",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Cycles in a Major Mode; Write Major Mode",
        "Counter": "0,1,2,3",
        "EventCode": "0x7",
        "EventName": "UNC_M_MAJOR_MODES.WRITE",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke total number of cycles spent in a major mode (selected by a filter) on the woke given channel.   Major modea are channel-wide, and not a per-rank (or dimm or bank) mode.",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Channel DLLOFF Cycles",
        "Counter": "0,1,2,3",
        "EventCode": "0x84",
        "EventName": "UNC_M_POWER_CHANNEL_DLLOFF",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles when all the woke ranks in the woke channel are in CKE Slow (DLLOFF) mode.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Channel PPD Cycles",
        "Counter": "0,1,2,3",
        "EventCode": "0x85",
        "EventName": "UNC_M_POWER_CHANNEL_PPD",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles when all the woke ranks in the woke channel are in PPD mode.  If IBT=off is enabled, then this can be used to count those cycles.  If it is not enabled, then this can count the woke number of cycles when that could have been taken advantage of.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK0",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK1",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK2",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x4",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK3",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x8",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK4",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x10",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK5",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x20",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK6",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x40",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x83",
        "EventName": "UNC_M_POWER_CKE_CYCLES.RANK7",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the woke counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the woke different CKE modes (APD, PPDS, PPDF).  This can be determined based on the woke system programming.  These events should commonly be used with Invert to get the woke number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the woke system and is not necessary).",
        "UMask": "0x80",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Critical Throttle Cycles",
        "Counter": "0,1,2,3",
        "EventCode": "0x86",
        "EventName": "UNC_M_POWER_CRITICAL_THROTTLE_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles when the woke iMC is in critical thermal throttling.  When this happens, all traffic is blocked.  This should be rare unless something bad is going on in the woke platform.  There is no filtering by rank for this event.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Clock-Enabled Self-Refresh",
        "Counter": "0,1,2,3",
        "EventCode": "0x43",
        "EventName": "UNC_M_POWER_SELF_REFRESH",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles when the woke iMC is in self-refresh and the woke iMC still has a clock.  This happens in some package C-states.  For example, the woke PCU may ask the woke iMC to enter self-refresh even though some of the woke cores are still processing.  One use of this is for Monroe technology.  Self-refresh is required during package C3 and C6, but there is no clock in the woke iMC at this time, so it is not possible to count these cases.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK0",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK1",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK2",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x4",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK3",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x8",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK4",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x10",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK5",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x20",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK6",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x40",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
        "Counter": "0,1,2,3",
        "EventCode": "0x41",
        "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK7",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles while the woke iMC is being throttled by either thermal constraints or by the woke PCU throttling.  It is not possible to distinguish between the woke two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the woke same time, the woke counter will only increment by 1.",
        "UMask": "0x80",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Preemption Count; Read over Read Preemption",
        "Counter": "0,1,2,3",
        "EventCode": "0x8",
        "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_RD",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of times a read in the woke iMC preempts another read or write.  Generally reads to an open page are issued ahead of requests to closed pages.  This improves the woke page hit rate of the woke system.  However, high priority requests can cause pages of active requests to be closed in order to get them out.  This will reduce the woke latency of the woke high-priority request at the woke expense of lower bandwidth and increased overall average latency.",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Preemption Count; Read over Write Preemption",
        "Counter": "0,1,2,3",
        "EventCode": "0x8",
        "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_WR",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of times a read in the woke iMC preempts another read or write.  Generally reads to an open page are issued ahead of requests to closed pages.  This improves the woke page hit rate of the woke system.  However, high priority requests can cause pages of active requests to be closed in order to get them out.  This will reduce the woke latency of the woke high-priority request at the woke expense of lower bandwidth and increased overall average latency.",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM Precharge commands.; Precharge due to timer expiration",
        "Counter": "0,1,2,3",
        "EventCode": "0x2",
        "EventName": "UNC_M_PRE_COUNT.PAGE_CLOSE",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of DRAM Precharge commands sent on this channel.",
        "UMask": "0x2",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "DRAM Precharge commands.; Precharges due to page miss",
        "Counter": "0,1,2,3",
        "EventCode": "0x2",
        "EventName": "UNC_M_PRE_COUNT.PAGE_MISS",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of DRAM Precharge commands sent on this channel.",
        "UMask": "0x1",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Pending Queue Full Cycles",
        "Counter": "0,1,2,3",
        "EventCode": "0x12",
        "EventName": "UNC_M_RPQ_CYCLES_FULL",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles when the woke Read Pending Queue is full.  When the woke RPQ is full, the woke HA will not be able to issue any additional read requests into the woke iMC.  This count should be similar count in the woke HA which tracks the woke number of cycles that the woke HA has no RPQ credits, just somewhat smaller to account for the woke credit return overhead.  We generally do not expect to see RPQ become full except for potentially during Write Major Mode or while running with slow DRAM.  This event only tracks non-ISOC queue entries.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Pending Queue Not Empty",
        "Counter": "0,1,2,3",
        "EventCode": "0x11",
        "EventName": "UNC_M_RPQ_CYCLES_NE",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles that the woke Read Pending Queue is not empty.  This can then be used to calculate the woke average occupancy (in conjunction with the woke Read Pending Queue Occupancy count).  The RPQ is used to schedule reads out to the woke memory controller and to track the woke requests.  Requests allocate into the woke RPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC.  They deallocate after the woke CAS command has been issued to memory.  This filter is to be used in conjunction with the woke occupancy filter so that one can correctly track the woke average occupancies for schedulable entries and scheduled requests.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Pending Queue Allocations",
        "Counter": "0,1,2,3",
        "EventCode": "0x10",
        "EventName": "UNC_M_RPQ_INSERTS",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of allocations into the woke Read Pending Queue.  This queue is used to schedule reads out to the woke memory controller and to track the woke requests.  Requests allocate into the woke RPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC.  They deallocate after the woke CAS command has been issued to memory.  This includes both ISOCH and non-ISOCH requests.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Read Pending Queue Occupancy",
        "Counter": "0,1,2,3",
        "EventCode": "0x80",
        "EventName": "UNC_M_RPQ_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the woke occupancies of the woke Read Pending Queue each cycle.  This can then be used to calculate both the woke average occupancy (in conjunction with the woke number of cycles not empty) and the woke average latency (in conjunction with the woke number of allocations).  The RPQ is used to schedule reads out to the woke memory controller and to track the woke requests.  Requests allocate into the woke RPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC. They deallocate after the woke CAS command has been issued to memory.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue Full Cycles",
        "Counter": "0,1,2,3",
        "EventCode": "0x22",
        "EventName": "UNC_M_WPQ_CYCLES_FULL",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles when the woke Write Pending Queue is full.  When the woke WPQ is full, the woke HA will not be able to issue any additional read requests into the woke iMC.  This count should be similar count in the woke HA which tracks the woke number of cycles that the woke HA has no WPQ credits, just somewhat smaller to account for the woke credit return overhead.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue Not Empty",
        "Counter": "0,1,2,3",
        "EventCode": "0x21",
        "EventName": "UNC_M_WPQ_CYCLES_NE",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of cycles that the woke Write Pending Queue is not empty.  This can then be used to calculate the woke average queue occupancy (in conjunction with the woke WPQ Occupancy Accumulation count).  The WPQ is used to schedule write out to the woke memory controller and to track the woke writes.  Requests allocate into the woke WPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the woke perspective of the woke rest of the woke system) as soon they have 'posted' to the woke iMC.  This is not to be confused with actually performing the woke write to DRAM.  Therefore, the woke average latency for this queue is actually not useful for deconstruction intermediate write latencies.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue Allocations",
        "Counter": "0,1,2,3",
        "EventCode": "0x20",
        "EventName": "UNC_M_WPQ_INSERTS",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of allocations into the woke Write Pending Queue.  This can then be used to calculate the woke average queuing latency (in conjunction with the woke WPQ occupancy count).  The WPQ is used to schedule write out to the woke memory controller and to track the woke writes.  Requests allocate into the woke WPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the woke perspective of the woke rest of the woke system) as soon they have 'posted' to the woke iMC.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue Occupancy",
        "Counter": "0,1,2,3",
        "EventCode": "0x81",
        "EventName": "UNC_M_WPQ_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the woke occupancies of the woke Write Pending Queue each cycle.  This can then be used to calculate both the woke average queue occupancy (in conjunction with the woke number of cycles not empty) and the woke average latency (in conjunction with the woke number of allocations).  The WPQ is used to schedule write out to the woke memory controller and to track the woke writes.  Requests allocate into the woke WPQ soon after they enter the woke memory controller, and need credits for an entry in this buffer before being sent from the woke HA to the woke iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the woke perspective of the woke rest of the woke system) as soon they have 'posted' to the woke iMC.  This is not to be confused with actually performing the woke write to DRAM.  Therefore, the woke average latency for this queue is actually not useful for deconstruction intermediate write latencies.  So, we provide filtering based on if the woke request has posted or not.  By using the woke 'not posted' filter, we can track how long writes spent in the woke iMC before completions were sent to the woke HA.  The 'posted' filter, on the woke other hand, provides information about how much queueing is actually happening in the woke iMC for writes before they are actually issued to memory.  High average occupancies will generally coincide with high write major mode counts.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue CAM Match",
        "Counter": "0,1,2,3",
        "EventCode": "0x23",
        "EventName": "UNC_M_WPQ_READ_HIT",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of times a request hits in the woke WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the woke WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the woke WPQ instead of going to memory.  Writes that hit will overwrite the woke existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
        "Unit": "iMC"
    },
    {
        "BriefDescription": "Write Pending Queue CAM Match",
        "Counter": "0,1,2,3",
        "EventCode": "0x24",
        "EventName": "UNC_M_WPQ_WRITE_HIT",
        "PerPkg": "1",
        "PublicDescription": "Counts the woke number of times a request hits in the woke WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the woke WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the woke WPQ instead of going to memory.  Writes that hit will overwrite the woke existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
        "Unit": "iMC"
    }
]
