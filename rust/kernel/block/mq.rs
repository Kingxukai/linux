// SPDX-License-Identifier: GPL-2.0

//! This module provides types for implementing block drivers that interface the
//! blk-mq subsystem.
//!
//! To implement a block device driver, a Rust module must do the woke following:
//!
//! - Implement [`Operations`] for a type `T`.
//! - Create a [`TagSet<T>`].
//! - Create a [`GenDisk<T>`], via the woke [`GenDiskBuilder`].
//! - Add the woke disk to the woke system by calling [`GenDiskBuilder::build`] passing in
//!   the woke `TagSet` reference.
//!
//! The types available in this module that have direct C counterparts are:
//!
//! - The [`TagSet`] type that abstracts the woke C type `struct tag_set`.
//! - The [`GenDisk`] type that abstracts the woke C type `struct gendisk`.
//! - The [`Request`] type that abstracts the woke C type `struct request`.
//!
//! The kernel will interface with the woke block device driver by calling the woke method
//! implementations of the woke `Operations` trait.
//!
//! IO requests are passed to the woke driver as [`kernel::types::ARef<Request>`]
//! instances. The `Request` type is a wrapper around the woke C `struct request`.
//! The driver must mark end of processing by calling one of the
//! `Request::end`, methods. Failure to do so can lead to deadlock or timeout
//! errors. Please note that the woke C function `blk_mq_start_request` is implicitly
//! called when the woke request is queued with the woke driver.
//!
//! The `TagSet` is responsible for creating and maintaining a mapping between
//! `Request`s and integer ids as well as carrying a pointer to the woke vtable
//! generated by `Operations`. This mapping is useful for associating
//! completions from hardware with the woke correct `Request` instance. The `TagSet`
//! determines the woke maximum queue depth by setting the woke number of `Request`
//! instances available to the woke driver, and it determines the woke number of queues to
//! instantiate for the woke driver. If possible, a driver should allocate one queue
//! per core, to keep queue data local to a core.
//!
//! One `TagSet` instance can be shared between multiple `GenDisk` instances.
//! This can be useful when implementing drivers where one piece of hardware
//! with one set of IO resources are represented to the woke user as multiple disks.
//!
//! One significant difference between block device drivers implemented with
//! these Rust abstractions and drivers implemented in C, is that the woke Rust
//! drivers have to own a reference count on the woke `Request` type when the woke IO is
//! in flight. This is to ensure that the woke C `struct request` instances backing
//! the woke Rust `Request` instances are live while the woke Rust driver holds a
//! reference to the woke `Request`. In addition, the woke conversion of an integer tag to
//! a `Request` via the woke `TagSet` would not be sound without this bookkeeping.
//!
//! [`GenDisk`]: gen_disk::GenDisk
//! [`GenDisk<T>`]: gen_disk::GenDisk
//! [`GenDiskBuilder`]: gen_disk::GenDiskBuilder
//! [`GenDiskBuilder::build`]: gen_disk::GenDiskBuilder::build
//!
//! # Examples
//!
//! ```rust
//! use kernel::{
//!     alloc::flags,
//!     block::mq::*,
//!     new_mutex,
//!     prelude::*,
//!     sync::{Arc, Mutex},
//!     types::{ARef, ForeignOwnable},
//! };
//!
//! struct MyBlkDevice;
//!
//! #[vtable]
//! impl Operations for MyBlkDevice {
//!
//!     fn queue_rq(rq: ARef<Request<Self>>, _is_last: bool) -> Result {
//!         Request::end_ok(rq);
//!         Ok(())
//!     }
//!
//!     fn commit_rqs() {}
//! }
//!
//! let tagset: Arc<TagSet<MyBlkDevice>> =
//!     Arc::pin_init(TagSet::new(1, 256, 1), flags::GFP_KERNEL)?;
//! let mut disk = gen_disk::GenDiskBuilder::new()
//!     .capacity_sectors(4096)
//!     .build(format_args!("myblk"), tagset)?;
//!
//! # Ok::<(), kernel::error::Error>(())
//! ```

pub mod gen_disk;
mod operations;
mod raw_writer;
mod request;
mod tag_set;

pub use operations::Operations;
pub use request::Request;
pub use tag_set::TagSet;
