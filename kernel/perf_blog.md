Help me write a technical blog post. I want those tiles to be direct. No nonsense. and keep trying to maintain the style I am talking with with and don't add data beyond what I'm giving, you know just maybe refactor my my comments a little bit but don't add new information 

I'd like to cover some details about the perf subsystems in the subsystem in the Linux kernel because I want to add functionality To the kernel, I want to add the ability for users to to open perf events for a subsystem that does not have perf support yet specifically it's the resource control subsystem or for short, R-E-S-C-T-R-L. 

So in, I'd like to now cover some of the internals of the perf subsystem that might be helpful if either you're a user or you want to build the functionality for Perf. 

The system call perf_event_open is defined in kernel/events/core.c . The man page is `man perf_event_open` and here is a link https://man7.org/linux/man-pages/man2/perf_event_open.2.html

the caller to perf underscore event event_open. can supply a process, a CPU, and a Cgroup ID. for the entities that they want to measure. The Cgroup and process ID share the same input parameter and there is a flag to control that parameter if it refers to a cgroup or a pid. PERF_FLAG_PID_CGROUP. the implementation takes care of locating those resources If it's a process, then the task struct. For a CPU, it makes sure that the CPU is online. and for a c group it passes the file descriptive to the c group for further processing. 

Now, since there is significant amount of code that deals with group leaders for perf it makes sense to talk about it. so the user path parameter group underscore fd to perf underscore event underscore open Groups allow scheduling of events onto the event hardware, the PMU, as a group, all or none. and that is because many PMUs have a limit on the number of events that they can track at any given time. And so the kernel has a mechanism to multiplex these groups onto PMUs. Every perf event can have a group leader specified to it. and a group leader cannot have another leader. So this is a limited hierarchy. key, it's not, you cannot create trees with leaders. It's just there's a single leader and maybe every event might have a leader. Might have a leader and that's it. And perf_event_open handles the group leader, takes care of most of that for for whoever is implementing the PMU. it resolves. if the user specifies it, it resolves. the it resolves the group leader, and then it makes sure that all of the events in the group belong to a single hardware PMU. It doesn't allow because it's hard to schedule events over for multiple PMUs atomically. the PERC subsystem just doesn't try to do that the the implementation checks that only offends for the same hardware PMU are in under the same group so they can all be scheduled together. and it also allows software. software events to be added in case the user wants to make sure that it has the software events as well in the group that is allowed. So there is a little bit of code in there. if you're adding every Every group has a PMU that it belongs to. software events can belong to a hardware PMU, but there's just a single hardware PMU associated, the general PMU associated with a group leader. So there is code if you've added, if the user added a lot of software tasks and now they're adding the first hardware task to move all of, sorry, not tasks, events, to move all of the events to the hardware PMU. So there's some logic there if you're reading the code. 

There are two important data structures that link the perf_event struct to the PMU that is performing measurements and to the entity being monitored which is the task or CPU. Those data structures are perf_event_context is associated with the measured entity task or cpu and a perf_event_pmu_context is associated with a perf_event_context and the PMU. And there could be multiple perf events. that point that to the same perf event context and perf event PMU contexts. And in fact, the per fungus core event and then hold ref pound to both of these odd projects, the perf_event_context and the perf_event_pmu_context. and these are documented if you want to see more, on `struct perf_event_pmu_context` in `include/linux/perf_event.h`

perf_event_alloc That function allocates and initializes that struck perf_event. it also calls the function perf_init_event that returns the PMU for the event. This is where the lookup happens from the event type to the PMU associated with that event type. You can take a look at that function perf_init_event if you want to see how that is done. specifically. It seems to include functionality that tries to initialize the event on different PMUs using the event type. and the PMU can override the type field and so perf_init_event follows those type redirections to find the actual PMU associated with the events, with this redirection support. but I'm not going expand further here. This is also where the kernel resolves dynamic dynamic PMU IDs. So those are PMUs dynamically registered with the colonel and associated. that they're assigned an ID when they are registered. This is mentioned in the man page. so if you want to see more about that this is the function to look at.

Kernel code can register PMUs with `perf_pmu_register`. pmu developers can specify the behavior of their PMUs using the fields on `struct pmu`, which is defined in `include/linux/perf_event.h`. the code that runs as part of perf underscore event underscore open ensures that the user has the right permissions and that the PMU supports all of the features requested by the user. one of the struct pmu fields and that controls the supported behavior is `task_ctx_nr`. When `pmu->task_ctx_nr == perf_invalid_context`, it means that the PMU does not support task context. The `capabilities` field encodes some capabilities of the PMU. For example, perf events can be used in counter mode, where the user reads their values, or in sampling mode, where the hardware raises an interrupt after a certain number of events. When the PMU sets `event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT`, it means that the PMU does not support sampling mode.

Struct PMU contains several functions, functions, function pointers for different functionality of the PMU. to event_init initializes per underscore event struct. Add. and del and then deletes. for preventing the PMU. Start and stop. than read for reading events. and there are some optional functions. One of the functions that is not marked as optional, but it actually is is `sched_task`. it allows the PMU to request a callback to that function on every context switch on a specific CPU. But in order to make this happen, and the PMU needs to call the function `perf_sched_cb_inc` (link: https://elixir.bootlin.com/linux/v6.15.6/source/kernel/events/core.c#L3723) which enqueue the PMU's CPU context onto a per CPU callback list. So if you're not intending to use that function, you can avoid implementing the scheduling callback. 

The Intel uncore PMU registration is a small PMU configuration (link to `uncore_pmu_register`: https://elixir.bootlin.com/linux/v6.15.6/source/arch/x86/events/intel/uncore.c#L913). It is not minimal because it implements the `pmu_enable` and `pmu_disable` optional functions. The `attr_groups` are also optional; they allow the PMU developer to create attribute files and directories in `/sys/bus/event_source/devices/[pmu_name1]/`, for users to read information about the PMU. However they can be left as NULL such as in https://elixir.bootlin.com/linux/v6.15.6/source/arch/alpha/kernel/perf_event.c#L755 .


some links to embed:
 - perf_event_open: https://elixir.bootlin.com/linux/v6.15.6/source/kernel/events/core.c#L13121
 - struct perf_event_pmu_context: https://elixir.bootlin.com/linux/v6.15.6/source/include/linux/perf_event.h#L103
 - perf_event_alloc: https://elixir.bootlin.com/linux/v6.15.6/source/kernel/events/core.c#L12598
 - perf_init_event: https://elixir.bootlin.com/linux/v6.15.6/source/kernel/events/core.c#L12413
 - perf_pmu_register: https://elixir.bootlin.com/linux/v6.15.6/source/kernel/events/core.c#L12218
 - struct pmu: https://elixir.bootlin.com/linux/v6.15.6/source/include/linux/perf_event.h#L322