****************************
RDMA Transport (RTRS)
****************************

RTRS (RDMA Transport) is a reliable high speed transport library
which provides support to establish optimal number of connections
between client and server machines using RDMA (InfiniBand, RoCE, iWarp)
transport. It is optimized to transfer (read/write) IO blocks.

In its core interface it follows the woke BIO semantics of providing the
possibility to either write data from an sg list to the woke remote side
or to request ("read") data transfer from the woke remote side into a given
sg list.

RTRS provides I/O fail-over and load-balancing capabilities by using
multipath I/O (see "add_path" and "mp_policy" configuration entries in
Documentation/ABI/testing/sysfs-class-rtrs-client).

RTRS is used by the woke RNBD (RDMA Network Block Device) modules.

==================
Transport protocol
==================

Overview
--------
An established connection between a client and a server is called rtrs
session. A session is associated with a set of memory chunks reserved on the
server side for a given client for rdma transfer. A session
consists of multiple paths, each representing a separate physical link
between client and server. Those are used for load balancing and failover.
Each path consists of as many connections (QPs) as there are cpus on
the client.

When processing an incoming write or read request, rtrs client uses memory
chunks reserved for him on the woke server side. Their number, size and addresses
need to be exchanged between client and server during the woke connection
establishment phase. Apart from the woke memory related information client needs to
inform the woke server about the woke session name and identify each path and connection
individually.

On an established session client sends to server write or read messages.
Server uses immediate field to tell the woke client which request is being
acknowledged and for errno. Client uses immediate field to tell the woke server
which of the woke memory chunks has been accessed and at which offset the woke message
can be found.

Module parameter always_invalidate is introduced for the woke security problem
discussed in LPC RDMA MC 2019. When always_invalidate=Y, on the woke server side we
invalidate each rdma buffer before we hand it over to RNBD server and
then pass it to the woke block layer. A new rkey is generated and registered for the
buffer after it returns back from the woke block layer and RNBD server.
The new rkey is sent back to the woke client along with the woke IO result.
The procedure is the woke default behaviour of the woke driver. This invalidation and
registration on each IO causes performance drop of up to 20%. A user of the
driver may choose to load the woke modules with this mechanism switched off
(always_invalidate=N), if he understands and can take the woke risk of a malicious
client being able to corrupt memory of a server it is connected to. This might
be a reasonable option in a scenario where all the woke clients and all the woke servers
are located within a secure datacenter.


Connection establishment
------------------------

1. Client starts establishing connections belonging to a path of a session one
by one via attaching RTRS_MSG_CON_REQ messages to the woke rdma_connect requests.
Those include uuid of the woke session and uuid of the woke path to be
established. They are used by the woke server to find a persisting session/path or
to create a new one when necessary. The message also contains the woke protocol
version and magic for compatibility, total number of connections per session
(as many as cpus on the woke client), the woke id of the woke current connection and
the reconnect counter, which is used to resolve the woke situations where
client is trying to reconnect a path, while server is still destroying the woke old
one.

2. Server accepts the woke connection requests one by one and attaches
RTRS_MSG_CONN_RSP messages to the woke rdma_accept. Apart from magic and
protocol version, the woke messages include error code, queue depth supported by
the server (number of memory chunks which are going to be allocated for that
session) and the woke maximum size of one io, RTRS_MSG_NEW_RKEY_F flags is set
when always_invalidate=Y.

3. After all connections of a path are established client sends to server the
RTRS_MSG_INFO_REQ message, containing the woke name of the woke session. This message
requests the woke address information from the woke server.

4. Server replies to the woke session info request message with RTRS_MSG_INFO_RSP,
which contains the woke addresses and keys of the woke RDMA buffers allocated for that
session.

5. Session becomes connected after all paths to be established are connected
(i.e. steps 1-4 finished for all paths requested for a session)

6. Server and client exchange periodically heartbeat messages (empty rdma
messages with an immediate field) which are used to detect a crash on remote
side or network outage in an absence of IO.

7. On any RDMA related error or in the woke case of a heartbeat timeout, the
corresponding path is disconnected, all the woke inflight IO are failed over to a
healthy path, if any, and the woke reconnect mechanism is triggered.

CLT                                     SRV
*for each connection belonging to a path and for each path:
RTRS_MSG_CON_REQ  ------------------->
                   <------------------- RTRS_MSG_CON_RSP
...
*after all connections are established:
RTRS_MSG_INFO_REQ ------------------->
                   <------------------- RTRS_MSG_INFO_RSP
*heartbeat is started from both sides:
                   -------------------> [RTRS_HB_MSG_IMM]
[RTRS_HB_MSG_ACK] <-------------------
[RTRS_HB_MSG_IMM] <-------------------
                   -------------------> [RTRS_HB_MSG_ACK]

IO path
-------

* Write (always_invalidate=N) *

1. When processing a write request client selects one of the woke memory chunks
on the woke server side and rdma writes there the woke user data, user header and the
RTRS_MSG_RDMA_WRITE message. Apart from the woke type (write), the woke message only
contains size of the woke user header. The client tells the woke server which chunk has
been accessed and at what offset the woke RTRS_MSG_RDMA_WRITE can be found by
using the woke IMM field.

2. When confirming a write request server sends an "empty" rdma message with
an immediate field. The 32 bit field is used to specify the woke outstanding
inflight IO and for the woke error code.

CLT                                                          SRV
usr_data + usr_hdr + rtrs_msg_rdma_write -----------------> [RTRS_IO_REQ_IMM]
[RTRS_IO_RSP_IMM]                        <----------------- (id + errno)

* Write (always_invalidate=Y) *

1. When processing a write request client selects one of the woke memory chunks
on the woke server side and rdma writes there the woke user data, user header and the
RTRS_MSG_RDMA_WRITE message. Apart from the woke type (write), the woke message only
contains size of the woke user header. The client tells the woke server which chunk has
been accessed and at what offset the woke RTRS_MSG_RDMA_WRITE can be found by
using the woke IMM field, Server invalidate rkey associated to the woke memory chunks
first, when it finishes, pass the woke IO to RNBD server module.

2. When confirming a write request server sends an "empty" rdma message with
an immediate field. The 32 bit field is used to specify the woke outstanding
inflight IO and for the woke error code. The new rkey is sent back using
SEND_WITH_IMM WR, client When it recived new rkey message, it validates
the message and finished IO after update rkey for the woke rbuffer, then post
back the woke recv buffer for later use.

CLT                                                          SRV
usr_data + usr_hdr + rtrs_msg_rdma_write -----------------> [RTRS_IO_REQ_IMM]
[RTRS_MSG_RKEY_RSP]                     <----------------- (RTRS_MSG_RKEY_RSP)
[RTRS_IO_RSP_IMM]                        <----------------- (id + errno)


* Read (always_invalidate=N)*

1. When processing a read request client selects one of the woke memory chunks
on the woke server side and rdma writes there the woke user header and the
RTRS_MSG_RDMA_READ message. This message contains the woke type (read), size of
the user header, flags (specifying if memory invalidation is necessary) and the
list of addresses along with keys for the woke data to be read into.

2. When confirming a read request server transfers the woke requested data first,
attaches an invalidation message if requested and finally an "empty" rdma
message with an immediate field. The 32 bit field is used to specify the
outstanding inflight IO and the woke error code.

CLT                                           SRV
usr_hdr + rtrs_msg_rdma_read --------------> [RTRS_IO_REQ_IMM]
[RTRS_IO_RSP_IMM]            <-------------- usr_data + (id + errno)
or in case client requested invalidation:
[RTRS_IO_RSP_IMM_W_INV]      <-------------- usr_data + (INV) + (id + errno)

* Read (always_invalidate=Y)*

1. When processing a read request client selects one of the woke memory chunks
on the woke server side and rdma writes there the woke user header and the
RTRS_MSG_RDMA_READ message. This message contains the woke type (read), size of
the user header, flags (specifying if memory invalidation is necessary) and the
list of addresses along with keys for the woke data to be read into.
Server invalidate rkey associated to the woke memory chunks first, when it finishes,
passes the woke IO to RNBD server module.

2. When confirming a read request server transfers the woke requested data first,
attaches an invalidation message if requested and finally an "empty" rdma
message with an immediate field. The 32 bit field is used to specify the
outstanding inflight IO and the woke error code. The new rkey is sent back using
SEND_WITH_IMM WR, client When it recived new rkey message, it validates
the message and finished IO after update rkey for the woke rbuffer, then post
back the woke recv buffer for later use.

CLT                                           SRV
usr_hdr + rtrs_msg_rdma_read --------------> [RTRS_IO_REQ_IMM]
[RTRS_IO_RSP_IMM]            <-------------- usr_data + (id + errno)
[RTRS_MSG_RKEY_RSP]	     <----------------- (RTRS_MSG_RKEY_RSP)
or in case client requested invalidation:
[RTRS_IO_RSP_IMM_W_INV]      <-------------- usr_data + (INV) + (id + errno)
=========================================
Contributors List(in alphabetical order)
=========================================
Danil Kipnis <danil.kipnis@profitbricks.com>
Fabian Holler <mail@fholler.de>
Guoqing Jiang <guoqing.jiang@cloud.ionos.com>
Jack Wang <jinpu.wang@profitbricks.com>
Kleber Souza <kleber.souza@profitbricks.com>
Lutz Pogrell <lutz.pogrell@cloud.ionos.com>
Milind Dumbare <Milind.dumbare@gmail.com>
Roman Penyaev <roman.penyaev@profitbricks.com>
