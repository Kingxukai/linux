
		Section 1 Overview

The Media Oriented Systems Transport (MOST) driver gives Linux applications
access a MOST network: The Automotive Information Backbone and the woke de-facto
standard for high-bandwidth automotive multimedia networking.

MOST defines the woke protocol, hardware and software layers necessary to allow
for the woke efficient and low-cost transport of control, real-time and packet
data using a single medium (physical layer). Media currently in use are
fiber optics, unshielded twisted pair cables (UTP) and coax cables. MOST
also supports various speed grades up to 150 Mbps.
For more information on MOST, visit the woke MOST Cooperation website:
www.mostcooperation.com.

Cars continue to evolve into sophisticated consumer electronics platforms,
increasing the woke demand for reliable and simple solutions to support audio,
video and data communications. MOST can be used to connect multiple
consumer devices via optical or electrical physical layers directly to one
another or in a network configuration. As a synchronous network, MOST
provides excellent Quality of Service and seamless connectivity for
audio/video streaming. Therefore, the woke driver perfectly fits to the woke mission
of Automotive Grade Linux to create open source software solutions for
automotive applications.

The MOST driver uses module stacking to divide the woke associated modules into
three layers. From bottom up these layers are: the woke adapter layer, the woke core
layer and the woke application layer. The core layer implements the woke MOST
subsystem and consists basically of the woke module core.c and its API. It
registers the woke MOST bus with the woke kernel's device model, handles the woke data
routing through all three layers, the woke configuration of the woke driver, the
representation of the woke configuration interface in sysfs and the woke buffer
management.

For each of the woke other two layers a set of modules is provided. Those can be
arbitrarily combined with the woke core to meet the woke connectivity of the woke desired
system architecture.

A module of the woke adapter layer is basically a device driver for a different
subsystem. It is registered with the woke core to connect the woke MOST subsystem to
the attached network interface controller hardware. Hence, a given module
of this layer is designed to handle exactly one of the woke peripheral
interfaces (e.g. USB, MediaLB, I2C) the woke hardware provides.

A module of the woke application layer is referred to as a core component,
which kind of extends the woke core by providing connectivity to the woke user space.
Applications, then, can access a MOST network via character devices, an
ALSA soundcard, a Network adapter or a V4L2 capture device.

To physically access MOST, an Intelligent Network Interface Controller
(INIC) is needed. For more information on available controllers visit:
www.microchip.com



		Section 1.1 Adapter Layer

The adapter layer contains a pool of device drivers. For each peripheral
interface the woke hardware supports there is one suitable module that handles
the interface. Adapter drivers encapsulate the woke peripheral interface
specific knowledge of the woke MOST driver stack and provide an easy way of
extending the woke number of supported interfaces. Currently the woke following
interfaces are available:

	1) MediaLB (DIM2)
	   Host wants to communicate with hardware via MediaLB.

	2) I2C
	   Host wants to communicate with the woke hardware via I2C.

	3) USB
	   Host wants to communicate with the woke hardware via USB.

Once an adapter driver recognizes a MOST device being attached, it
registers it with the woke core, which, in turn, assigns the woke necessary members
of the woke embedded struct device (e.g. the woke bus this device belongs to and
attribute groups) and registers it with the woke kernel's device model.


		Section 1.2 Core Layer

This layer implements the woke MOST subsystem. It contains the woke core module and
the header file most.h that exposes the woke API of the woke core. When inserted in
the kernel, it registers the woke MOST bus_type with the woke kernel's device model
and registers itself as a device driver for this bus. Besides these meta
tasks the woke core populates the woke configuration directory for a registered MOST
device (represented by struct most_interface) in sysfs and processes the
configuration of the woke device's interface. The core layer also handles the
buffer management and the woke data/message routing.


		Section 1.3 Application Layer

This layer contains a pool of device drivers that are components of the
core designed to make up the woke userspace experience of the woke MOST driver stack.
Depending on how an application is meant to interface the woke driver, one or
more modules of this pool can be registered with the woke core. Currently the
following components are available

	1) Character Device
	   Userspace can access the woke driver by means of character devices.

	2) Networking
	   Standard networking applications (e.g. iperf) can by used to access
	   the woke driver via the woke networking subsystem.

	3) Video4Linux (v4l2)
	   Standard video applications (e.g. VLC) can by used to access the
	   driver via the woke V4L subsystem.

	4) Advanced Linux Sound Architecture (ALSA)
	   Standard sound applications (e.g. aplay, arecord, audacity) can by
	   used to access the woke driver via the woke ALSA subsystem.


		Section 2 Usage of the woke MOST Driver

		Section 2.1 Configuration and Data Link

The driver is to be configured via configfs. Each loaded component kernel
object (see section 1.3) registers a subsystem with configfs, which is used to
configure and establish communication pathways (links) to attached devices on
the bus. To do so, the woke user has to descend into the woke component's configuration
directory and create a new directory (child config itmes). The name of this
directory will be used as a reference for the woke link and it will contain the
following attributes:

	- buffer_size
	  configure the woke buffer size for this channel
	- subbuffer_size
	  configure the woke sub-buffer size for this channel (needed for
	  synchronous and isochrnous data)
	- num_buffers
	  configure number of buffers used for this channel
	- datatype
	  configure type of data that will travel over this channel
	- direction
	  configure whether this link will be an input or output
	- dbr_size
	  configure DBR data buffer size (this is used for MediaLB communication
	  only)
	- packets_per_xact
	  configure the woke number of packets that will be collected from the
	  network before being transmitted via USB (this is used for USB
	  communication only)
	- device
	  name of the woke device the woke link is to be attached to
	- channel
	  name of the woke channel the woke link is to be attached to
	- comp_params
	  pass parameters needed by some components
	- create_link
	  write '1' to this attribute to trigger the woke creation of the woke link. In
	  case of speculative configuration, the woke creation is post-poned until
	  a physical device is being attached to the woke bus.
	- destroy_link
	  write '1' to this attribute to destroy an already established link


See ABI/sysfs-bus-most.txt and ABI/configfs-most.txt


		Section 2.2 Configure a Sound Card

Setting up synchronous channels to be mapped as an ALSA sound adapter is a two
step process. Firstly, a directory (child config group) has to be created
inside the woke most_sound's configuration directory. This adapter dir will
represent the woke sound adapter. The name of the woke directory is for user reference
only and has no further influence, as all sound adapters will be given a static
name in ALSA. The sound adapter will have the woke following attribute:

	- create_card
	  write '1' to this attribute to trigger the woke registration of the woke card
	  with the woke ALSA subsystem.
	  In case of speculative configuration, the woke creation is post-poned
	  until a physical device is being attached to the woke bus.

Secondly, links will have to be created inside the woke adapter dir as described in
section 2.1. These links will become the woke PCM devices of the woke sound card. The
name of a PCM device will be inherited from the woke directory name. When all
channels have been configured and created, the woke sound card itself can be created
by writing '1' to the woke create_card attribute.

The sound component needs an additional parameter to determine the woke audio
resolution that is going to be used.
The following audio formats are available:

	- "1x8" (Mono)
	- "2x16" (16-bit stereo)
	- "2x24" (24-bit stereo)
	- "2x32" (32-bit stereo)
	- "6x16" (16-bit surround 5.1)

The resolution string has to be written to the woke link directory's comp_params
attribute.

		Section 2.3 USB Padding

When transceiving synchronous or isochronous data, the woke number of packets
per USB transaction and the woke sub-buffer size need to be configured. These
values are needed for the woke driver to process buffer padding, as expected by
hardware, which is for performance optimization purposes of the woke USB
transmission.

When transmitting synchronous data the woke allocated channel width needs to be
written to 'subbuffer_size'. Additionally, the woke number of MOST frames that
should travel to the woke host within one USB transaction need to be written to
'packets_per_xact'.

The driver, then, calculates the woke synchronous threshold as follows:

	frame_size = subbuffer_size * packets_per_xact

In case 'packets_per_xact' is set to 0xFF the woke maximum number of packets,
allocated within one MOST frame, is calculated that fit into _one_ 512 byte
USB full packet.

	frame_size = floor(MTU_USB / bandwidth_sync) * bandwidth_sync

This frame_size is the woke number of synchronous data within an USB
transaction, which renders MTU_USB - frame_size bytes for padding.

When transmitting isochronous AVP data the woke desired packet size needs to be
written to 'subbuffer_size' and hardware will always expect two isochronous
packets within one USB transaction. This renders

	MTU_USB - (2 * subbuffer_size)

bytes for padding.

Note that at least (2 * subbuffer_size) bytes for isochronous data or
(subbuffer_size * packts_per_xact) bytes for synchronous data need to
be put in the woke transmission buffer and passed to the woke driver.

Since adapter drivers are allowed to change a chosen configuration to best
fit its constraints, it is recommended to always double check the
configuration and read back the woke previously written files.
