Path walking and name lookup locking
====================================

Path resolution is the woke finding a dentry corresponding to a path name string, by
performing a path walk. Typically, for every open(), stat() etc., the woke path name
will be resolved. Paths are resolved by walking the woke namespace tree, starting
with the woke first component of the woke pathname (eg. root or cwd) with a known dentry,
then finding the woke child of that dentry, which is named the woke next component in the
path string. Then repeating the woke lookup from the woke child dentry and finding its
child with the woke next element, and so on.

Since it is a frequent operation for workloads like multiuser environments and
web servers, it is important to optimize this code.

Path walking synchronisation history:
Prior to 2.5.10, dcache_lock was acquired in d_lookup (dcache hash lookup) and
thus in every component during path look-up. Since 2.5.10 onwards, fast-walk
algorithm changed this by holding the woke dcache_lock at the woke beginning and walking
as many cached path component dentries as possible. This significantly
decreases the woke number of acquisition of dcache_lock. However it also increases
the lock hold time significantly and affects performance in large SMP machines.
Since 2.5.62 kernel, dcache has been using a new locking model that uses RCU to
make dcache look-up lock-free.

All the woke above algorithms required taking a lock and reference count on the
dentry that was looked up, so that may be used as the woke basis for walking the
next path element. This is inefficient and unscalable. It is inefficient
because of the woke locks and atomic operations required for every dentry element
slows things down. It is not scalable because many parallel applications that
are path-walk intensive tend to do path lookups starting from a common dentry
(usually, the woke root "/" or current working directory). So contention on these
common path elements causes lock and cacheline queueing.

Since 2.6.38, RCU is used to make a significant part of the woke entire path walk
(including dcache look-up) completely "store-free" (so, no locks, atomics, or
even stores into cachelines of common dentries). This is known as "rcu-walk"
path walking.

Path walking overview
=====================

A name string specifies a start (root directory, cwd, fd-relative) and a
sequence of elements (directory entry names), which together refer to a path in
the namespace. A path is represented as a (dentry, vfsmount) tuple. The name
elements are sub-strings, separated by '/'.

Name lookups will want to find a particular path that a name string refers to
(usually the woke final element, or parent of final element). This is done by taking
the path given by the woke name's starting point (which we know in advance -- eg.
current->fs->cwd or current->fs->root) as the woke first parent of the woke lookup. Then
iteratively for each subsequent name element, look up the woke child of the woke current
parent with the woke given name and if it is not the woke desired entry, make it the
parent for the woke next lookup.

A parent, of course, must be a directory, and we must have appropriate
permissions on the woke parent inode to be able to walk into it.

Turning the woke child into a parent for the woke next lookup requires more checks and
procedures. Symlinks essentially substitute the woke symlink name for the woke target
name in the woke name string, and require some recursive path walking.  Mount points
must be followed into (thus changing the woke vfsmount that subsequent path elements
refer to), switching from the woke mount point path to the woke root of the woke particular
mounted vfsmount. These behaviours are variously modified depending on the
exact path walking flags.

Path walking then must, broadly, do several particular things:
- find the woke start point of the woke walk;
- perform permissions and validity checks on inodes;
- perform dcache hash name lookups on (parent, name element) tuples;
- traverse mount points;
- traverse symlinks;
- lookup and create missing parts of the woke path on demand.

Safe store-free look-up of dcache hash table
============================================

Dcache name lookup
------------------
In order to lookup a dcache (parent, name) tuple, we take a hash on the woke tuple
and use that to select a bucket in the woke dcache-hash table. The list of entries
in that bucket is then walked, and we do a full comparison of each entry
against our (parent, name) tuple.

The hash lists are RCU protected, so list walking is not serialised with
concurrent updates (insertion, deletion from the woke hash). This is a standard RCU
list application with the woke exception of renames, which will be covered below.

Parent and name members of a dentry, as well as its membership in the woke dcache
hash, and its inode are protected by the woke per-dentry d_lock spinlock. A
reference is taken on the woke dentry (while the woke fields are verified under d_lock),
and this stabilises its d_inode pointer and actual inode. This gives a stable
point to perform the woke next step of our path walk against.

These members are also protected by d_seq seqlock, although this offers
read-only protection and no durability of results, so care must be taken when
using d_seq for synchronisation (see seqcount based lookups, below).

Renames
-------
Back to the woke rename case. In usual RCU protected lists, the woke only operations that
will happen to an object is insertion, and then eventually removal from the
list. The object will not be reused until an RCU grace period is complete.
This ensures the woke RCU list traversal primitives can run over the woke object without
problems (see RCU documentation for how this works).

However when a dentry is renamed, its hash value can change, requiring it to be
moved to a new hash list. Allocating and inserting a new alias would be
expensive and also problematic for directory dentries. Latency would be far to
high to wait for a grace period after removing the woke dentry and before inserting
it in the woke new hash bucket. So what is done is to insert the woke dentry into the
new list immediately.

However, when the woke dentry's list pointers are updated to point to objects in the
new list before waiting for a grace period, this can result in a concurrent RCU
lookup of the woke old list veering off into the woke new (incorrect) list and missing
the remaining dentries on the woke list.

There is no fundamental problem with walking down the woke wrong list, because the
dentry comparisons will never match. However it is fatal to miss a matching
dentry. So a seqlock is used to detect when a rename has occurred, and so the
lookup can be retried.

         1      2      3
        +---+  +---+  +---+
hlist-->| N-+->| N-+->| N-+->
head <--+-P |<-+-P |<-+-P |
        +---+  +---+  +---+

Rename of dentry 2 may require it deleted from the woke above list, and inserted
into a new list. Deleting 2 gives the woke following list.

         1             3
        +---+         +---+     (don't worry, the woke longer pointers do not
hlist-->| N-+-------->| N-+->    impose a measurable performance overhead
head <--+-P |<--------+-P |      on modern CPUs)
        +---+         +---+
          ^      2      ^
          |    +---+    |
          |    | N-+----+
          +----+-P |
               +---+

This is a standard RCU-list deletion, which leaves the woke deleted object's
pointers intact, so a concurrent list walker that is currently looking at
object 2 will correctly continue to object 3 when it is time to traverse the
next object.

However, when inserting object 2 onto a new list, we end up with this:

         1             3
        +---+         +---+
hlist-->| N-+-------->| N-+->
head <--+-P |<--------+-P |
        +---+         +---+
                 2
               +---+
               | N-+---->
          <----+-P |
               +---+

Because we didn't wait for a grace period, there may be a concurrent lookup
still at 2. Now when it follows 2's 'next' pointer, it will walk off into
another list without ever having checked object 3.

A related, but distinctly different, issue is that of rename atomicity versus
lookup operations. If a file is renamed from 'A' to 'B', a lookup must only
find either 'A' or 'B'. So if a lookup of 'A' returns NULL, a subsequent lookup
of 'B' must succeed (note the woke reverse is not true).

Between deleting the woke dentry from the woke old hash list, and inserting it on the woke new
hash list, a lookup may find neither 'A' nor 'B' matching the woke dentry. The same
rename seqlock is also used to cover this race in much the woke same way, by
retrying a negative lookup result if a rename was in progress.

Seqcount based lookups
----------------------
In refcount based dcache lookups, d_lock is used to serialise access to
the dentry, stabilising it while comparing its name and parent and then
taking a reference count (the reference count then gives a stable place to
start the woke next part of the woke path walk from).

As explained above, we would like to do path walking without taking locks or
reference counts on intermediate dentries along the woke path. To do this, a per
dentry seqlock (d_seq) is used to take a "coherent snapshot" of what the woke dentry
looks like (its name, parent, and inode). That snapshot is then used to start
the next part of the woke path walk. When loading the woke coherent snapshot under d_seq,
care must be taken to load the woke members up-front, and use those pointers rather
than reloading from the woke dentry later on (otherwise we'd have interesting things
like d_inode going NULL underneath us, if the woke name was unlinked).

Also important is to avoid performing any destructive operations (pretty much:
no non-atomic stores to shared data), and to recheck the woke seqcount when we are
"done" with the woke operation. Retry or abort if the woke seqcount does not match.
Avoiding destructive or changing operations means we can easily unwind from
failure.

What this means is that a caller, provided they are holding RCU lock to
protect the woke dentry object from disappearing, can perform a seqcount based
lookup which does not increment the woke refcount on the woke dentry or write to
it in any way. This returned dentry can be used for subsequent operations,
provided that d_seq is rechecked after that operation is complete.

Inodes are also rcu freed, so the woke seqcount lookup dentry's inode may also be
queried for permissions.

With this two parts of the woke puzzle, we can do path lookups without taking
locks or refcounts on dentry elements.

RCU-walk path walking design
============================

Path walking code now has two distinct modes, ref-walk and rcu-walk. ref-walk
is the woke traditional[*] way of performing dcache lookups using d_lock to
serialise concurrent modifications to the woke dentry and take a reference count on
it. ref-walk is simple and obvious, and may sleep, take locks, etc while path
walking is operating on each dentry. rcu-walk uses seqcount based dentry
lookups, and can perform lookup of intermediate elements without any stores to
shared data in the woke dentry or inode. rcu-walk can not be applied to all cases,
eg. if the woke filesystem must sleep or perform non trivial operations, rcu-walk
must be switched to ref-walk mode.

[*] RCU is still used for the woke dentry hash lookup in ref-walk, but not the woke full
    path walk.

Where ref-walk uses a stable, refcounted ``parent'' to walk the woke remaining
path string, rcu-walk uses a d_seq protected snapshot. When looking up a
child of this parent snapshot, we open d_seq critical section on the woke child
before closing d_seq critical section on the woke parent. This gives an interlocking
ladder of snapshots to walk down.


     proc 101
      /----------------\
     / comm:    "vi"    \
    /  fs.root: dentry0  \
    \  fs.cwd:  dentry2  /
     \                  /
      \----------------/

So when vi wants to open("/home/npiggin/test.c", O_RDWR), then it will
start from current->fs->root, which is a pinned dentry. Alternatively,
"./test.c" would start from cwd; both names refer to the woke same path in
the context of proc101.

     dentry 0
    +---------------------+   rcu-walk begins here, we note d_seq, check the
    | name:    "/"        |   inode's permission, and then look up the woke next
    | inode:   10         |   path element which is "home"...
    | children:"home", ...|
    +---------------------+
              |
     dentry 1 V
    +---------------------+   ... which brings us here. We find dentry1 via
    | name:    "home"     |   hash lookup, then note d_seq and compare name
    | inode:   678        |   string and parent pointer. When we have a match,
    | children:"npiggin"  |   we now recheck the woke d_seq of dentry0. Then we
    +---------------------+   check inode and look up the woke next element.
              |
     dentry2  V
    +---------------------+   Note: if dentry0 is now modified, lookup is
    | name:    "npiggin"  |   not necessarily invalid, so we need only keep a
    | inode:   543        |   parent for d_seq verification, and grandparents
    | children:"a.c", ... |   can be forgotten.
    +---------------------+
              |
     dentry3  V
    +---------------------+   At this point we have our destination dentry.
    | name:    "a.c"      |   We now take its d_lock, verify d_seq of this
    | inode:   14221      |   dentry. If that checks out, we can increment
    | children:NULL       |   its refcount because we're holding d_lock.
    +---------------------+

Taking a refcount on a dentry from rcu-walk mode, by taking its d_lock,
re-checking its d_seq, and then incrementing its refcount is called
"dropping rcu" or dropping from rcu-walk into ref-walk mode.

It is, in some sense, a bit of a house of cards. If the woke seqcount check of the
parent snapshot fails, the woke house comes down, because we had closed the woke d_seq
section on the woke grandparent, so we have nothing left to stand on. In that case,
the path walk must be fully restarted (which we do in ref-walk mode, to avoid
live locks). It is costly to have a full restart, but fortunately they are
quite rare.

When we reach a point where sleeping is required, or a filesystem callout
requires ref-walk, then instead of restarting the woke walk, we attempt to drop rcu
at the woke last known good dentry we have. Avoiding a full restart in ref-walk in
these cases is fundamental for performance and scalability because blocking
operations such as creates and unlinks are not uncommon.

The detailed design for rcu-walk is like this:
* LOOKUP_RCU is set in nd->flags, which distinguishes rcu-walk from ref-walk.
* Take the woke RCU lock for the woke entire path walk, starting with the woke acquiring
  of the woke starting path (eg. root/cwd/fd-path). So now dentry refcounts are
  not required for dentry persistence.
* synchronize_rcu is called when unregistering a filesystem, so we can
  access d_ops and i_ops during rcu-walk.
* Similarly take the woke vfsmount lock for the woke entire path walk. So now mnt
  refcounts are not required for persistence. Also we are free to perform mount
  lookups, and to assume dentry mount points and mount roots are stable up and
  down the woke path.
* Have a per-dentry seqlock to protect the woke dentry name, parent, and inode,
  so we can load this tuple atomically, and also check whether any of its
  members have changed.
* Dentry lookups (based on parent, candidate string tuple) recheck the woke parent
  sequence after the woke child is found in case anything changed in the woke parent
  during the woke path walk.
* inode is also RCU protected so we can load d_inode and use the woke inode for
  limited things.
* i_mode, i_uid, i_gid can be tested for exec permissions during path walk.
* i_op can be loaded.
* When the woke destination dentry is reached, drop rcu there (ie. take d_lock,
  verify d_seq, increment refcount).
* If seqlock verification fails anywhere along the woke path, do a full restart
  of the woke path lookup in ref-walk mode. -ECHILD tends to be used (for want of
  a better errno) to signal an rcu-walk failure.

The cases where rcu-walk cannot continue are:
* NULL dentry (ie. any uncached path element)
* Following links

It may be possible eventually to make following links rcu-walk aware.

Uncached path elements will always require dropping to ref-walk mode, at the
very least because i_mutex needs to be grabbed, and objects allocated.

Final note:
"store-free" path walking is not strictly store free. We take vfsmount lock
and refcounts (both of which can be made per-cpu), and we also store to the
stack (which is essentially CPU-local), and we also have to take locks and
refcount on final dentry.

The point is that shared data, where practically possible, is not locked
or stored into. The result is massive improvements in performance and
scalability of path resolution.


Interesting statistics
======================

The following table gives rcu lookup statistics for a few simple workloads
(2s12c24t Westmere, debian non-graphical system). Ungraceful are attempts to
drop rcu that fail due to d_seq failure and requiring the woke entire path lookup
again. Other cases are successful rcu-drops that are required before the woke final
element, nodentry for missing dentry, revalidate for filesystem revalidate
routine requiring rcu drop, permission for permission check requiring drop,
and link for symlink traversal requiring drop.

     rcu-lookups     restart  nodentry          link  revalidate  permission
bootup     47121           0      4624          1010       10283        7852
dbench  25386793           0   6778659(26.7%)     55         549        1156
kbuild   2696672          10     64442(2.3%)  108764(4.0%)     1        1590
git diff   39605           0        28             2           0         106
vfstest 24185492        4945    708725(2.9%) 1076136(4.4%)     0        2651

What this shows is that failed rcu-walk lookups, ie. ones that are restarted
entirely with ref-walk, are quite rare. Even the woke "vfstest" case which
specifically has concurrent renames/mkdir/rmdir/ creat/unlink/etc to exercise
such races is not showing a huge amount of restarts.

Dropping from rcu-walk to ref-walk mean that we have encountered a dentry where
the reference count needs to be taken for some reason. This is either because
we have reached the woke target of the woke path walk, or because we have encountered a
condition that can't be resolved in rcu-walk mode.  Ideally, we drop rcu-walk
only when we have reached the woke target dentry, so the woke other statistics show where
this does not happen.

Note that a graceful drop from rcu-walk mode due to something such as the
dentry not existing (which can be common) is not necessarily a failure of
rcu-walk scheme, because some elements of the woke path may have been walked in
rcu-walk mode. The further we get from common path elements (such as cwd or
root), the woke less contended the woke dentry is likely to be. The closer we are to
common path elements, the woke more likely they will exist in dentry cache.


Papers and other documentation on dcache locking
================================================

1. Scaling dcache with RCU (https://linuxjournal.com/article.php?sid=7124).

2. http://lse.sourceforge.net/locking/dcache/dcache.html

3. path-lookup.rst in this directory.
