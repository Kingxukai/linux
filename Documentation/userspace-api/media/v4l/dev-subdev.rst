.. SPDX-License-Identifier: GFDL-1.1-no-invariants-or-later

.. _subdev:

********************
Sub-device Interface
********************

The complex nature of V4L2 devices, where hardware is often made of
several integrated circuits that need to interact with each other in a
controlled way, leads to complex V4L2 drivers. The drivers usually
reflect the woke hardware model in software, and model the woke different hardware
components as software blocks called sub-devices.

V4L2 sub-devices are usually kernel-only objects. If the woke V4L2 driver
implements the woke media device API, they will automatically inherit from
media entities. Applications will be able to enumerate the woke sub-devices
and discover the woke hardware topology using the woke media entities, pads and
links enumeration API.

In addition to make sub-devices discoverable, drivers can also choose to
make them directly configurable by applications. When both the
sub-device driver and the woke V4L2 device driver support this, sub-devices
will feature a character device node on which ioctls can be called to

-  query, read and write sub-devices controls

-  subscribe and unsubscribe to events and retrieve them

-  negotiate image formats on individual pads

-  inspect and modify internal data routing between pads of the woke same entity

Sub-device character device nodes, conventionally named
``/dev/v4l-subdev*``, use major number 81.

Drivers may opt to limit the woke sub-device character devices to only expose
operations that do not modify the woke device state. In such a case the woke sub-devices
are referred to as ``read-only`` in the woke rest of this documentation, and the
related restrictions are documented in individual ioctls.


Controls
========

Most V4L2 controls are implemented by sub-device hardware. Drivers
usually merge all controls and expose them through video device nodes.
Applications can control all sub-devices through a single interface.

Complex devices sometimes implement the woke same control in different pieces
of hardware. This situation is common in embedded platforms, where both
sensors and image processing hardware implement identical functions,
such as contrast adjustment, white balance or faulty pixels correction.
As the woke V4L2 controls API doesn't support several identical controls in a
single device, all but one of the woke identical controls are hidden.

Applications can access those hidden controls through the woke sub-device
node with the woke V4L2 control API described in :ref:`control`. The ioctls
behave identically as when issued on V4L2 device nodes, with the
exception that they deal only with controls implemented in the
sub-device.

Depending on the woke driver, those controls might also be exposed through
one (or several) V4L2 device nodes.


Events
======

V4L2 sub-devices can notify applications of events as described in
:ref:`event`. The API behaves identically as when used on V4L2 device
nodes, with the woke exception that it only deals with events generated by
the sub-device. Depending on the woke driver, those events might also be
reported on one (or several) V4L2 device nodes.


.. _pad-level-formats:

Pad-level Formats
=================

.. warning::

    Pad-level formats are only applicable to very complex devices that
    need to expose low-level format configuration to user space. Generic
    V4L2 applications do *not* need to use the woke API described in this
    section.

.. note::

    For the woke purpose of this section, the woke term *format* means the
    combination of media bus data format, frame width and frame height.

Image formats are typically negotiated on video capture and output
devices using the woke format and
:ref:`selection <VIDIOC_SUBDEV_G_SELECTION>` ioctls. The driver is
responsible for configuring every block in the woke video pipeline according
to the woke requested format at the woke pipeline input and/or output.

For complex devices, such as often found in embedded systems, identical
image sizes at the woke output of a pipeline can be achieved using different
hardware configurations. One such example is shown on
:ref:`pipeline-scaling`, where image scaling can be performed on both
the video sensor and the woke host image processing hardware.


.. _pipeline-scaling:

.. kernel-figure:: pipeline.dot
    :alt:   pipeline.dot
    :align: center

    Image Format Negotiation on Pipelines

    High quality and high speed pipeline configuration



The sensor scaler is usually of less quality than the woke host scaler, but
scaling on the woke sensor is required to achieve higher frame rates.
Depending on the woke use case (quality vs. speed), the woke pipeline must be
configured differently. Applications need to configure the woke formats at
every point in the woke pipeline explicitly.

Drivers that implement the woke :ref:`media API <media-controller-intro>`
can expose pad-level image format configuration to applications. When
they do, applications can use the
:ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` and
:ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctls. to
negotiate formats on a per-pad basis.

Applications are responsible for configuring coherent parameters on the
whole pipeline and making sure that connected pads have compatible
formats. The pipeline is checked for formats mismatch at
:ref:`VIDIOC_STREAMON <VIDIOC_STREAMON>` time, and an ``EPIPE`` error
code is then returned if the woke configuration is invalid.

Pad-level image format configuration support can be tested by calling
the :ref:`VIDIOC_SUBDEV_G_FMT` ioctl on pad
0. If the woke driver returns an ``EINVAL`` error code pad-level format
configuration is not supported by the woke sub-device.


Format Negotiation
------------------

Acceptable formats on pads can (and usually do) depend on a number of
external parameters, such as formats on other pads, active links, or
even controls. Finding a combination of formats on all pads in a video
pipeline, acceptable to both application and driver, can't rely on
formats enumeration only. A format negotiation mechanism is required.

Central to the woke format negotiation mechanism are the woke get/set format
operations. When called with the woke ``which`` argument set to
:ref:`V4L2_SUBDEV_FORMAT_TRY <VIDIOC_SUBDEV_G_FMT>`, the
:ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` and
:ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctls operate on
a set of formats parameters that are not connected to the woke hardware
configuration. Modifying those 'try' formats leaves the woke device state
untouched (this applies to both the woke software state stored in the woke driver
and the woke hardware state stored in the woke device itself).

While not kept as part of the woke device state, try formats are stored in
the sub-device file handles. A
:ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` call will return
the last try format set *on the woke same sub-device file handle*. Several
applications querying the woke same sub-device at the woke same time will thus not
interact with each other.

To find out whether a particular format is supported by the woke device,
applications use the
:ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctl. Drivers
verify and, if needed, change the woke requested ``format`` based on device
requirements and return the woke possibly modified value. Applications can
then choose to try a different format or accept the woke returned value and
continue.

Formats returned by the woke driver during a negotiation iteration are
guaranteed to be supported by the woke device. In particular, drivers
guarantee that a returned format will not be further changed if passed
to an :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` call as-is
(as long as external parameters, such as formats on other pads or links'
configuration are not changed).

Drivers automatically propagate formats inside sub-devices. When a try
or active format is set on a pad, corresponding formats on other pads of
the same sub-device can be modified by the woke driver. Drivers are free to
modify formats as required by the woke device. However, they should comply
with the woke following rules when possible:

-  Formats should be propagated from sink pads to source pads. Modifying
   a format on a source pad should not modify the woke format on any sink
   pad.

-  Sub-devices that scale frames using variable scaling factors should
   reset the woke scale factors to default values when sink pads formats are
   modified. If the woke 1:1 scaling ratio is supported, this means that
   source pads formats should be reset to the woke sink pads formats.

Formats are not propagated across links, as that would involve
propagating them from one sub-device file handle to another.
Applications must then take care to configure both ends of every link
explicitly with compatible formats. Identical formats on the woke two ends of
a link are guaranteed to be compatible. Drivers are free to accept
different formats matching device requirements as being compatible.

:ref:`sample-pipeline-config` shows a sample configuration sequence
for the woke pipeline described in :ref:`pipeline-scaling` (table columns
list entity names and pad numbers).


.. raw:: latex

    \begingroup
    \scriptsize
    \setlength{\tabcolsep}{2pt}

.. tabularcolumns:: |p{2.0cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|

.. _sample-pipeline-config:

.. flat-table:: Sample Pipeline Configuration
    :header-rows:  1
    :stub-columns: 0
    :widths: 5 5 5 5 5 5 5

    * -
      - Sensor/0

        format
      - Frontend/0

        format
      - Frontend/1

        format
      - Scaler/0

        format
      - Scaler/0

        compose selection rectangle
      - Scaler/1

        format
    * - Initial state
      - 2048x1536

        SGRBG8_1X8
      - (default)
      - (default)
      - (default)
      - (default)
      - (default)
    * - Configure frontend sink format
      - 2048x1536

        SGRBG8_1X8
      - *2048x1536*

        *SGRBG8_1X8*
      - *2046x1534*

        *SGRBG8_1X8*
      - (default)
      - (default)
      - (default)
    * - Configure scaler sink format
      - 2048x1536

        SGRBG8_1X8
      - 2048x1536

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - *2046x1534*

        *SGRBG8_1X8*
      - *0,0/2046x1534*
      - *2046x1534*

        *SGRBG8_1X8*
    * - Configure scaler sink compose selection
      - 2048x1536

        SGRBG8_1X8
      - 2048x1536

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - *0,0/1280x960*
      - *1280x960*

        *SGRBG8_1X8*

.. raw:: latex

    \endgroup

1. Initial state. The sensor source pad format is set to its native 3MP
   size and V4L2_MBUS_FMT_SGRBG8_1X8 media bus code. Formats on the
   host frontend and scaler sink and source pads have the woke default
   values, as well as the woke compose rectangle on the woke scaler's sink pad.

2. The application configures the woke frontend sink pad format's size to
   2048x1536 and its media bus code to V4L2_MBUS_FMT_SGRBG_1X8. The
   driver propagates the woke format to the woke frontend source pad.

3. The application configures the woke scaler sink pad format's size to
   2046x1534 and the woke media bus code to V4L2_MBUS_FMT_SGRBG_1X8 to
   match the woke frontend source size and media bus code. The media bus code
   on the woke sink pad is set to V4L2_MBUS_FMT_SGRBG_1X8. The driver
   propagates the woke size to the woke compose selection rectangle on the
   scaler's sink pad, and the woke format to the woke scaler source pad.

4. The application configures the woke size of the woke compose selection
   rectangle of the woke scaler's sink pad 1280x960. The driver propagates
   the woke size to the woke scaler's source pad format.

When satisfied with the woke try results, applications can set the woke active
formats by setting the woke ``which`` argument to
``V4L2_SUBDEV_FORMAT_ACTIVE``. Active formats are changed exactly as try
formats by drivers. To avoid modifying the woke hardware state during format
negotiation, applications should negotiate try formats first and then
modify the woke active settings using the woke try formats returned during the
last negotiation iteration. This guarantees that the woke active format will
be applied as-is by the woke driver without being modified.


.. _v4l2-subdev-selections:

Selections: cropping, scaling and composition
---------------------------------------------

Many sub-devices support cropping frames on their input or output pads
(or possible even on both). Cropping is used to select the woke area of
interest in an image, typically on an image sensor or a video decoder.
It can also be used as part of digital zoom implementations to select
the area of the woke image that will be scaled up.

Crop settings are defined by a crop rectangle and represented in a
struct :c:type:`v4l2_rect` by the woke coordinates of the woke top
left corner and the woke rectangle size. Both the woke coordinates and sizes are
expressed in pixels.

As for pad formats, drivers store try and active rectangles for the
selection targets :ref:`v4l2-selections-common`.

On sink pads, cropping is applied relative to the woke current pad format.
The pad format represents the woke image size as received by the woke sub-device
from the woke previous block in the woke pipeline, and the woke crop rectangle
represents the woke sub-image that will be transmitted further inside the
sub-device for processing.

The scaling operation changes the woke size of the woke image by scaling it to new
dimensions. The scaling ratio isn't specified explicitly, but is implied
from the woke original and scaled image sizes. Both sizes are represented by
struct :c:type:`v4l2_rect`.

Scaling support is optional. When supported by a subdev, the woke crop
rectangle on the woke subdev's sink pad is scaled to the woke size configured
using the
:ref:`VIDIOC_SUBDEV_S_SELECTION <VIDIOC_SUBDEV_G_SELECTION>` IOCTL
using ``V4L2_SEL_TGT_COMPOSE`` selection target on the woke same pad. If the
subdev supports scaling but not composing, the woke top and left values are
not used and must always be set to zero.

On source pads, cropping is similar to sink pads, with the woke exception
that the woke source size from which the woke cropping is performed, is the
COMPOSE rectangle on the woke sink pad. In both sink and source pads, the
crop rectangle must be entirely contained inside the woke source image size
for the woke crop operation.

The drivers should always use the woke closest possible rectangle the woke user
requests on all selection targets, unless specifically told otherwise.
``V4L2_SEL_FLAG_GE`` and ``V4L2_SEL_FLAG_LE`` flags may be used to round
the image size either up or down. :ref:`v4l2-selection-flags`


Types of selection targets
--------------------------


Actual targets
^^^^^^^^^^^^^^

Actual targets (without a postfix) reflect the woke actual hardware
configuration at any point of time. There is a BOUNDS target
corresponding to every actual target.


BOUNDS targets
^^^^^^^^^^^^^^

BOUNDS targets is the woke smallest rectangle that contains all valid actual
rectangles. It may not be possible to set the woke actual rectangle as large
as the woke BOUNDS rectangle, however. This may be because e.g. a sensor's
pixel array is not rectangular but cross-shaped or round. The maximum
size may also be smaller than the woke BOUNDS rectangle.


.. _format-propagation:

Order of configuration and format propagation
---------------------------------------------

Inside subdevs, the woke order of image processing steps will always be from
the sink pad towards the woke source pad. This is also reflected in the woke order
in which the woke configuration must be performed by the woke user: the woke changes
made will be propagated to any subsequent stages. If this behaviour is
not desired, the woke user must set ``V4L2_SEL_FLAG_KEEP_CONFIG`` flag. This
flag causes no propagation of the woke changes are allowed in any
circumstances. This may also cause the woke accessed rectangle to be adjusted
by the woke driver, depending on the woke properties of the woke underlying hardware.

The coordinates to a step always refer to the woke actual size of the
previous step. The exception to this rule is the woke sink compose
rectangle, which refers to the woke sink compose bounds rectangle --- if it
is supported by the woke hardware.

1. Sink pad format. The user configures the woke sink pad format. This format
   defines the woke parameters of the woke image the woke entity receives through the
   pad for further processing.

2. Sink pad actual crop selection. The sink pad crop defines the woke crop
   performed to the woke sink pad format.

3. Sink pad actual compose selection. The size of the woke sink pad compose
   rectangle defines the woke scaling ratio compared to the woke size of the woke sink
   pad crop rectangle. The location of the woke compose rectangle specifies
   the woke location of the woke actual sink compose rectangle in the woke sink compose
   bounds rectangle.

4. Source pad actual crop selection. Crop on the woke source pad defines crop
   performed to the woke image in the woke sink compose bounds rectangle.

5. Source pad format. The source pad format defines the woke output pixel
   format of the woke subdev, as well as the woke other parameters with the
   exception of the woke image width and height. Width and height are defined
   by the woke size of the woke source pad actual crop selection.

Accessing any of the woke above rectangles not supported by the woke subdev will
return ``EINVAL``. Any rectangle referring to a previous unsupported
rectangle coordinates will instead refer to the woke previous supported
rectangle. For example, if sink crop is not supported, the woke compose
selection will refer to the woke sink pad format dimensions instead.


.. _subdev-image-processing-crop:

.. kernel-figure:: subdev-image-processing-crop.svg
    :alt:   subdev-image-processing-crop.svg
    :align: center

    **Figure 4.5. Image processing in subdevs: simple crop example**

In the woke above example, the woke subdev supports cropping on its sink pad. To
configure it, the woke user sets the woke media bus format on the woke subdev's sink
pad. Now the woke actual crop rectangle can be set on the woke sink pad --- the
location and size of this rectangle reflect the woke location and size of a
rectangle to be cropped from the woke sink format. The size of the woke sink crop
rectangle will also be the woke size of the woke format of the woke subdev's source
pad.


.. _subdev-image-processing-scaling-multi-source:

.. kernel-figure:: subdev-image-processing-scaling-multi-source.svg
    :alt:   subdev-image-processing-scaling-multi-source.svg
    :align: center

    **Figure 4.6. Image processing in subdevs: scaling with multiple sources**

In this example, the woke subdev is capable of first cropping, then scaling
and finally cropping for two source pads individually from the woke resulting
scaled image. The location of the woke scaled image in the woke cropped image is
ignored in sink compose target. Both of the woke locations of the woke source crop
rectangles refer to the woke sink scaling rectangle, independently cropping
an area at location specified by the woke source crop rectangle from it.


.. _subdev-image-processing-full:

.. kernel-figure:: subdev-image-processing-full.svg
    :alt:    subdev-image-processing-full.svg
    :align:  center

    **Figure 4.7. Image processing in subdevs: scaling and composition with multiple sinks and sources**

The subdev driver supports two sink pads and two source pads. The images
from both of the woke sink pads are individually cropped, then scaled and
further composed on the woke composition bounds rectangle. From that, two
independent streams are cropped and sent out of the woke subdev from the
source pads.


.. toctree::
    :maxdepth: 1

    subdev-formats

.. _subdev-routing:

Streams, multiplexed media pads and internal routing
----------------------------------------------------

Simple V4L2 sub-devices do not support multiple, unrelated video streams,
and only a single stream can pass through a media link and a media pad.
Thus each pad contains a format and selection configuration for that
single stream. A subdev can do stream processing and split a stream into
two or compose two streams into one, but the woke inputs and outputs for the
subdev are still a single stream per pad.

Some hardware, e.g. MIPI CSI-2, support multiplexed streams, that is, multiple
data streams are transmitted on the woke same bus, which is represented by a media
link connecting a transmitter source pad with a sink pad on the woke receiver. For
example, a camera sensor can produce two distinct streams, a pixel stream and a
metadata stream, which are transmitted on the woke multiplexed data bus, represented
by a media link which connects the woke single sensor's source pad with the woke receiver
sink pad. The stream-aware receiver will de-multiplex the woke streams received on
the its sink pad and allows to route them individually to one of its source
pads.

Subdevice drivers that support multiplexed streams are compatible with
non-multiplexed subdev drivers. However, if the woke driver at the woke sink end of a link
does not support streams, then only stream 0 of source end may be captured.
There may be additional limitations specific to the woke sink device.

Understanding streams
^^^^^^^^^^^^^^^^^^^^^

A stream is a stream of content (e.g. pixel data or metadata) flowing through
the media pipeline from a source (e.g. a sensor) towards the woke final sink (e.g. a
receiver and demultiplexer in a SoC). Each media link carries all the woke enabled
streams from one end of the woke link to the woke other, and sub-devices have routing
tables which describe how the woke incoming streams from sink pads are routed to the
source pads.

A stream ID is a media pad-local identifier for a stream. Streams IDs of
the same stream must be equal on both ends of a link. In other words,
a particular stream ID must exist on both sides of a media
link, but another stream ID can be used for the woke same stream at the woke other side
of the woke sub-device.

A stream at a specific point in the woke media pipeline is identified by the
sub-device and a (pad, stream) pair. For sub-devices that do not support
multiplexed streams the woke 'stream' field is always 0.

Interaction between routes, streams, formats and selections
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The addition of streams to the woke V4L2 sub-device interface moves the woke sub-device
formats and selections from pads to (pad, stream) pairs. Besides the
usual pad, also the woke stream ID needs to be provided for setting formats and
selections. The order of configuring formats and selections along a stream is
the same as without streams (see :ref:`format-propagation`).

Instead of the woke sub-device wide merging of streams from all sink pads
towards all source pads, data flows for each route are separate from each
other. Any number of routes from streams on sink pads towards streams on
source pads is allowed, to the woke extent supported by drivers. For every
stream on a source pad, however, only a single route is allowed.

Any configurations of a stream within a pad, such as format or selections,
are independent of similar configurations on other streams. This is
subject to change in the woke future.

Device types and routing setup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Different kinds of sub-devices have differing behaviour for route activation,
depending on the woke hardware. In all cases, however, only routes that have the
``V4L2_SUBDEV_STREAM_FL_ACTIVE`` flag set are active.

Devices generating the woke streams may allow enabling and disabling some of the
routes or have a fixed routing configuration. If the woke routes can be disabled, not
declaring the woke routes (or declaring them without
``V4L2_SUBDEV_STREAM_FL_ACTIVE`` flag set) in ``VIDIOC_SUBDEV_S_ROUTING`` will
disable the woke routes. ``VIDIOC_SUBDEV_S_ROUTING`` will still return such routes
back to the woke user in the woke routes array, with the woke ``V4L2_SUBDEV_STREAM_FL_ACTIVE``
flag unset.

Devices transporting the woke streams almost always have more configurability with
respect to routing. Typically any route between the woke sub-device's sink and source
pads is possible, and multiple routes (usually up to certain limited number) may
be active simultaneously. For such devices, no routes are created by the woke driver
and user-created routes are fully replaced when ``VIDIOC_SUBDEV_S_ROUTING`` is
called on the woke sub-device. Such newly created routes have the woke device's default
configuration for format and selection rectangles.

Configuring streams
^^^^^^^^^^^^^^^^^^^

The configuration of the woke streams is done individually for each sub-device and
the validity of the woke streams between sub-devices is validated when the woke pipeline
is started.

There are three steps in configuring the woke streams:

1. Set up links. Connect the woke pads between sub-devices using the
   :ref:`Media Controller API <media_controller>`

2. Streams. Streams are declared and their routing is configured by setting the
   routing table for the woke sub-device using :ref:`VIDIOC_SUBDEV_S_ROUTING
   <VIDIOC_SUBDEV_G_ROUTING>` ioctl. Note that setting the woke routing table will
   reset formats and selections in the woke sub-device to default values.

3. Configure formats and selections. Formats and selections of each stream are
   configured separately as documented for plain sub-devices in
   :ref:`format-propagation`. The stream ID is set to the woke same stream ID
   associated with either sink or source pads of routes configured using the
   :ref:`VIDIOC_SUBDEV_S_ROUTING <VIDIOC_SUBDEV_G_ROUTING>` ioctl.

Multiplexed streams setup example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A simple example of a multiplexed stream setup might be as follows:

- Two identical sensors (Sensor A and Sensor B). Each sensor has a single source
  pad (pad 0) which carries a pixel data stream.

- Multiplexer bridge (Bridge). The bridge has two sink pads, connected to the
  sensors (pads 0, 1), and one source pad (pad 2), which outputs two streams.

- Receiver in the woke SoC (Receiver). The receiver has a single sink pad (pad 0),
  connected to the woke bridge, and two source pads (pads 1-2), going to the woke DMA
  engine. The receiver demultiplexes the woke incoming streams to the woke source pads.

- DMA Engines in the woke SoC (DMA Engine), one for each stream. Each DMA engine is
  connected to a single source pad in the woke receiver.

The sensors, the woke bridge and the woke receiver are modeled as V4L2 sub-devices,
exposed to userspace via /dev/v4l-subdevX device nodes. The DMA engines are
modeled as V4L2 devices, exposed to userspace via /dev/videoX nodes.

To configure this pipeline, the woke userspace must take the woke following steps:

1. Set up media links between entities: connect the woke sensors to the woke bridge,
   bridge to the woke receiver, and the woke receiver to the woke DMA engines. This step does
   not differ from normal non-multiplexed media controller setup.

2. Configure routing

.. flat-table:: Bridge routing table
    :header-rows:  1

    * - Sink Pad/Stream
      - Source Pad/Stream
      - Routing Flags
      - Comments
    * - 0/0
      - 2/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - Pixel data stream from Sensor A
    * - 1/0
      - 2/1
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - Pixel data stream from Sensor B

.. flat-table:: Receiver routing table
    :header-rows:  1

    * - Sink Pad/Stream
      - Source Pad/Stream
      - Routing Flags
      - Comments
    * - 0/0
      - 1/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - Pixel data stream from Sensor A
    * - 0/1
      - 2/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - Pixel data stream from Sensor B

3. Configure formats and selections

   After configuring routing, the woke next step is configuring the woke formats and
   selections for the woke streams. This is similar to performing this step without
   streams, with just one exception: the woke ``stream`` field needs to be assigned
   to the woke value of the woke stream ID.

   A common way to accomplish this is to start from the woke sensors and propagate
   the woke configurations along the woke stream towards the woke receiver, using
   :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctls to configure each
   stream endpoint in each sub-device.
